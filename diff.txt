diff --git a/app/RM_test/RM_test.cc b/app/RM_test/RM_test.cc
new file mode 100644
index 0000000..13814db
--- /dev/null
+++ b/app/RM_test/RM_test.cc
@@ -0,0 +1,62 @@
+// EPOS Semaphore Component Test Program
+
+#include <machine/display.h>
+#include <time.h>
+#include <synchronizer.h>
+#include <process.h>
+#include <real-time.h>
+#include <time.h>
+
+using namespace EPOS;
+
+RT_Thread* tasks[3];
+
+OStream cout;
+
+int s = 1000000; // Seconds
+
+Chronometer* cA = new Chronometer();
+void A() {
+    cout << "Thread A running..." << endl;
+    cA->start();
+    while (1) { // Busy wait 5s until it is preempted
+        cA->lap();
+        if (int(cA->read()) >= int(5*s)) break;
+    }
+    cA->reset();
+    cout << "Thread A finished" << endl;
+}
+
+Chronometer* cB = new Chronometer();
+void B() {
+    cout << "Thread B running..." << endl;
+    cB->start();
+    while (1) { // Busy wait 1s until it is preempted
+        cB->lap();
+        if (int(cB->read()) >= int(1*s)) break;
+    }
+    cB->reset();
+    cout << "Thread B finished" << endl;
+}
+
+Chronometer* cC = new Chronometer();
+void C() {
+    cout << "Thread C running..." << endl;
+    cC->start();
+    while (1) { // Busy wait 0.2s until it is preempted
+        cC->lap();
+        if (int(cC->read()) >= int(0.2*s)) break;
+    }
+    cC->reset();
+    cout << "Thread C finished" << endl;
+}
+
+int main()
+{
+    tasks[0] = new RT_Thread(&A, 10*s, 10*s);   // period = deadline = 10s
+    tasks[1] = new RT_Thread(&B, 4*s, 4*s);     // period = deadline = 4s
+    tasks[2] = new RT_Thread(&C, 1*s, 1*s);     // period = deadline = 1s
+    // C should run first and can preempt A and B
+    // B should run if C is not running and can preempt A
+    // A should run if neither C or B is running
+}
diff --git a/app/RM_test/RM_test_traits.h b/app/RM_test/RM_test_traits.h
new file mode 100644
index 0000000..5e61b4f
--- /dev/null
+++ b/app/RM_test/RM_test_traits.h
@@ -0,0 +1,155 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = ARMv7;
+    static const unsigned int MACHINE = Cortex;
+    static const unsigned int MODEL = Raspberry_Pi3;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RM Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    //static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+    static const bool debugged = true;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/app/RM_test/makefile b/app/RM_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/RM_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/heap_test/heap_test.cc b/app/heap_test/heap_test.cc
new file mode 100644
index 0000000..cea3c66
--- /dev/null
+++ b/app/heap_test/heap_test.cc
@@ -0,0 +1,26 @@
+#include <utility/ostream.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+char* alloc(int bytes) {
+    cout << "Allocating " << bytes << " bytes." << endl;
+    return new char[bytes];
+}
+
+int main()
+{
+    cout << "################################" << endl;
+    cout << "#       Entering main...       #" << endl;
+    cout << "# Testing the heap allocation! #" << endl;
+    cout << "################################" << endl;
+    alloc(1 << 2);
+    alloc(1 << 5);
+    alloc(1 << 10);
+    alloc(1 << 12);
+    alloc(1 << 14);
+    alloc(1 << 16);
+
+    return 0;
+}
diff --git a/app/heap_test/heap_test_traits.h b/app/heap_test/heap_test_traits.h
new file mode 100644
index 0000000..77a3de8
--- /dev/null
+++ b/app/heap_test/heap_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = ARMv7;
+    static const unsigned int MACHINE = Cortex;
+    static const unsigned int MODEL = Raspberry_Pi3;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RR Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/app/heap_test/makefile b/app/heap_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/heap_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/hello/hello_traits.h b/app/hello/hello_traits.h
index 77a3de8..01170b6 100644
--- a/app/hello/hello_traits.h
+++ b/app/hello/hello_traits.h
@@ -10,7 +10,7 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = ARMv7;
+    static const unsigned int ARCHITECTURE = ARMv8;
     static const unsigned int MACHINE = Cortex;
     static const unsigned int MODEL = Raspberry_Pi3;
     static const unsigned int CPUS = 1;
diff --git a/app/philosophers_dinner/philosophers_dinner_traits.h b/app/philosophers_dinner/philosophers_dinner_traits.h
index 77a3de8..8466d48 100644
--- a/app/philosophers_dinner/philosophers_dinner_traits.h
+++ b/app/philosophers_dinner/philosophers_dinner_traits.h
@@ -10,7 +10,7 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = ARMv7;
+    static const unsigned int ARCHITECTURE = ARMv8;
     static const unsigned int MACHINE = Cortex;
     static const unsigned int MODEL = Raspberry_Pi3;
     static const unsigned int CPUS = 1;
@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
 
-    typedef RR Criterion;
+    typedef RM Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/img/hello b/img/hello
new file mode 100755
index 0000000..bc8c9aa
Binary files /dev/null and b/img/hello differ
diff --git a/include/architecture/armv8/armv8_cpu.h b/include/architecture/armv8/armv8_cpu.h
new file mode 100644
index 0000000..d31a4b6
--- /dev/null
+++ b/include/architecture/armv8/armv8_cpu.h
@@ -0,0 +1,659 @@
+// EPOS ARMv8 CPU Mediator Declarations
+
+#ifndef __armv8_h
+#define __armv8_h
+
+#include <architecture/cpu.h>
+
+__BEGIN_SYS
+
+class ARMv8: protected CPU_Common
+{
+    friend class Init_System; // for CPU::init()
+
+protected:
+    static const bool multicore = Traits<System>::multicore;
+    static const bool multitask = Traits<System>::multitask;
+
+public:
+    // CPU Native Data Types
+    using CPU_Common::Reg8;
+    using CPU_Common::Reg16;
+    using CPU_Common::Reg32;
+    using CPU_Common::Reg64;
+    using CPU_Common::Reg;
+    using CPU_Common::Log_Addr;
+    using CPU_Common::Phy_Addr;
+
+    class Context
+    {
+    public:
+        Context() {}
+        Context(Log_Addr usp, Log_Addr ulr, Reg flags, Log_Addr  lr, Log_Addr pc): _usp(usp), _ulr(ulr), _flags(flags), _lr(lr), _pc(pc) {
+            if(Traits<Build>::hysterically_debugged || Traits<Thread>::trace_idle) {
+                _x0 = 0; _x1 = 1; _x2 = 2; _x3 = 3; _x4 = 4; _x5 = 5; _x6 = 6; _x7 = 7; _x8 = 8; _x9 = 9; _x10 = 10; _x11 = 11; _x12 = 12;
+            }
+        }
+
+    public:
+        Reg _usp;     // usp (only used in multitasking)
+        Reg _ulr;     // ulr (only used in multitasking)
+        Reg _flags;
+        Reg _x0;
+        Reg _x1;
+        Reg _x2;
+        Reg _x3;
+        Reg _x4;
+        Reg _x5;
+        Reg _x6;
+        Reg _x7;
+        Reg _x8;
+        Reg _x9;
+        Reg _x10;
+        Reg _x11;
+        Reg _x12;
+        Reg _lr;
+        Reg _pc;
+    };
+
+    // Interrupt Service Routines
+    typedef void (* ISR)();
+
+    // Fault Service Routines (exception handlers)
+    typedef void (* FSR)();
+
+protected:
+    ARMv8() {};
+
+public:
+    static Log_Addr pc() { Reg r; ASM("mov %0, pc" : "=r"(r) :); return r; } // due to RISC pipelining, PC is read with a +8 (4 for thumb) offset
+
+    static Log_Addr sp() { Reg r; ASM("mov %0, sp" : "=r"(r) :); return r; }
+    static void sp(Log_Addr sp) { ASM("mov sp, %0" : : "r"(Reg(sp))); ASM("isb"); }
+
+    static Reg fr() { Reg r; ASM("mov %0, x0" : "=r"(r)); return r; }
+    static void fr(Reg r) {  ASM("mov x0, %0" : : "r"(r) : "x0"); }
+
+    static Log_Addr ra() { Reg r; ASM("mov %0, lr" : "=r"(r) :); return r; } // due to RISC pipelining, PC is read with a +8 (4 for thumb) offset
+
+    static void halt() { ASM("wfi"); }
+
+    template<typename T>
+    static T tsl(volatile T & lock) {
+        register T old = 0;
+        //register T one = 1;
+        /*ASM("1: ldrexb  %0, [%1]        \n"
+            "   strexb  x3, %2, [%1]    \n"
+            "   cmp     x3, #0          \n"
+            "   bne     1b              \n" : "=&r"(old) : "r"(&lock), "r"(one) : "x3", "cc");*/
+        return old;
+    }
+
+    template<typename T>
+    static T finc(volatile T & value) {
+        register T old = 0;
+        /*if(sizeof(T) == sizeof(Reg8))
+            ASM("1: ldrexb  %0, [%1]        \n"
+                "   add     %0, #1          \n"
+                "   strexb  x3, %0, [%1]    \n"
+                "   cmp     x3, #0          \n"
+                "   bne     1b              \n" : "=&r"(old) : "r"(&value) : "x3", "cc");
+        else if(sizeof(T) == sizeof(Reg16))
+            ASM("1: ldrexh  %0, [%1]        \n"
+                "   add     %0, #1          \n"
+                "   strexh  x3, %0, [%1]    \n"
+                "   cmp     x3, #0          \n"
+                "   bne     1b              \n" : "=&r"(old) : "r"(&value) : "x3", "cc");
+        else
+            ASM("1: ldrex   %0, [%1]        \n"
+                "   add     %0, #1          \n"
+                "   strex   x3, %0, [%1]    \n"
+                "   cmp     x3, #0          \n"
+                "   bne     1b              \n" : "=&r"(old) : "r"(&value) : "x3", "cc");*/
+        return old - 1;
+    }
+
+    template<typename T>
+    static T fdec(volatile T & value) {
+        register T old = 0;
+        /*if(sizeof(T) == sizeof(Reg8))
+            ASM("1: ldrexb  %0, [%1]        \n"
+                "   sub     %0, #1          \n"
+                "   strexb  x3, %0, [%1]    \n"
+                "   cmp     x3, #0          \n"
+                "   bne     1b              \n" : "=&r"(old) : "r"(&value) : "x3", "cc");
+        else if(sizeof(T) == sizeof(Reg16))
+            ASM("1: ldrexh  %0, [%1]        \n"
+                "   sub     %0, #1          \n"
+                "   strexh  x3, %0, [%1]    \n"
+                "   cmp     x3, #0          \n"
+                "   bne     1b              \n" : "=&r"(old) : "r"(&value) : "x3", "cc");
+        else
+            ASM("1: ldrex   %0, [%1]        \n"
+                "   sub     %0, #1          \n"
+                "   strex   x3, %0, [%1]    \n"
+                "   cmp     x3, #0          \n"
+                "   bne     1b              \n" : "=&r"(old) : "r"(&value) : "x3", "cc");*/
+        return old + 1;
+    }
+
+    template <typename T>
+    static T cas(volatile T & value, T compare, T replacement) {
+        register T old = 0;
+        /*if(sizeof(T) == sizeof(Reg8))
+            ASM("1: ldrexb  %0, [%1]        \n"
+                "   cmp     %0, %2          \n"
+                "   bne     2f              \n"
+                "   strexb  x3, %3, [%1]    \n"
+                "   cmp     x3, #0          \n"
+                "   bne     1b              \n"
+                "2:                         \n" : "=&r"(old) : "r"(&value), "r"(compare), "r"(replacement) : "x3", "cc");
+        else if(sizeof(T) == sizeof(Reg16))
+            ASM("1: ldrexh  %0, [%1]        \n"
+                "   cmp     %0, %2          \n"
+                "   bne     2f              \n"
+                "   strexh  x3, %3, [%1]    \n"
+                "   cmp     x3, #0          \n"
+                "   bne     1b              \n"
+                "2:                         \n" : "=&r"(old) : "r"(&value), "r"(compare), "r"(replacement) : "x3", "cc");
+        else
+            ASM("1: ldrex   %0, [%1]        \n"
+                "   cmp     %0, %2          \n"
+                "   bne     2f              \n"
+                "   strex   x3, %3, [%1]    \n"
+                "   cmp     x3, #0          \n"
+                "   bne     1b              \n"
+                "2:                         \n" : "=&r"(old) : "r"(&value), "r"(compare), "r"(replacement) : "x3", "cc");*/
+        return old;
+    }
+
+    // ARMv8 specifics
+    static Reg x0() { Reg r; ASM("mov %0, x0" : "=r"(r) : : ); return r; }
+    static void x0(Reg r) { ASM("mov x0, %0" : : "r"(r): ); }
+
+    static Reg x1() { Reg r; ASM("mov %0, x1" : "=r"(r) : : ); return r; }
+    static void x1(Reg r) { ASM("mov x1, %0" : : "r"(r): ); }
+
+    static Reg sctlr() { Reg r; ASM("mrs %0, sctlr_el1" : "=r"(r)); return r; }
+    static void sctlr(Reg r) {  ASM("msr sctlr_el1, %0" : : "r"(r) : "x0"); }
+
+    static Reg actlr() { Reg r; ASM("mrs %0, actlr_el1" : "=r"(r)); return r; }
+    static void actlr(Reg r) {  ASM("msr actlr_el1, %0" : : "r"(r) : "x0"); }
+
+    static void dsb() { /*ASM("dsb");*/ }
+    static void isb() { ASM("isb"); }
+
+    static void svc() { ASM("svc 0x0"); }
+};
+
+class ARMv8_M: public ARMv8
+{
+public:
+    static const bool thumb = true;
+
+    // CPU Flags
+    typedef Reg Flags;
+    enum {
+        FLAG_THUMB      = 1 << 24,      // Thumb state
+        FLAG_Q          = 1 << 27,      // DSP Overflow
+        FLAG_V          = 1 << 28,      // Overflow
+        FLAG_C          = 1 << 29,      // Carry
+        FLAG_Z          = 1 << 30,      // Zero
+        FLAG_N          = 1 << 31       // Negative
+    };
+
+    // Exceptions
+    typedef Reg Exception_Id;
+    enum {                      // Priority
+        EXC_RESET       = 1,    // -3 (highest)
+        EXC_NMI         = 2,    // -2
+        EXC_HARD        = 3,    // -1
+        EXC_MPU         = 4,    // programmable
+        EXC_BUS         = 5,    // programmable
+        EXC_USAGE       = 6,    // programmable
+        EXC_SVCALL      = 11,   // programmable
+        EXC_DEBUG       = 12,   // programmable
+        EXC_PENDSV      = 14,   // programmable
+        EXC_SYSTICK     = 15    // programmable
+    };
+
+    // CPU Context
+    class Context: public ARMv8::Context
+    {
+    public:
+        Context() {}
+        Context(Log_Addr entry, Log_Addr exit, Log_Addr usp): ARMv8::Context(usp, exit | thumb, FLAG_THUMB, exit | thumb, entry | thumb) {}
+    };
+
+protected:
+    ARMv8_M() {};
+
+public:
+    static unsigned int id() { return 0; }
+    static unsigned int cores() { return 1; }
+
+    static void int_enable()  { ASM("cpsie i"); }
+    static void int_disable() { ASM("cpsid i"); }
+    static bool int_enabled() { return !int_disabled(); }
+    static bool int_disabled() {
+        bool disabled;
+        ASM("mrs %0, primask" : "=r"(disabled));
+        return disabled;
+    }
+
+    static void smp_barrier(unsigned long cores = cores()) { assert(cores == 1); }
+
+    static Reg pd() { return 0; }       // no MMU
+    static void pd(Reg r) {}            // no MMU
+
+    static void flush_tlb() {}          // no MMU
+    static void flush_tlb(Reg r) {}     // no MMU
+
+    // ARMv8-M specifics
+    static Flags flags() { Reg r; ASM("mrs %0, xpsr"       : "=r"(r) :); return r; }
+    static void flags(Flags r) {  ASM("msr xpsr_nzcvq, %0" : : "r"(r) : "cc"); }
+
+    static void psr_to_x12() { ASM("mrs x12, xpsr" : : : "x12"); }
+    static void x12_to_psr() {  ASM("msr xpsr_nzcvq, x12" : : : "cc"); }
+};
+
+class ARMv8_A: public ARMv8
+{
+public:
+    static const bool thumb = false;
+
+    // CPU Flags
+    typedef Reg Flags;
+    enum {
+        FLAG_M          = 0x1f << 0,       // Processor Mode (5 bits)
+        FLAG_T          = 1    << 5,       // Thumb state
+        FLAG_F          = 1    << 6,       // FIQ disable
+        FLAG_I          = 1    << 7,       // IRQ disable
+        FLAG_A          = 1    << 8,       // Imprecise Abort disable
+        FLAG_E          = 1    << 9,       // Endianess (0 ->> little, 1 -> big)
+        FLAG_GE         = 0xf  << 16,      // SIMD Greater than or Equal (4 bits)
+        FLAG_J          = 1    << 24,      // Jazelle state
+        FLAG_Q          = 1    << 27,      // Underflow and/or DSP saturation
+        FLAG_V          = 1    << 28,      // Overflow
+        FLAG_C          = 1    << 29,      // Carry
+        FLAG_Z          = 1    << 30,      // Zero
+        FLAG_N          = 1    << 31,      // Negative
+
+        // FLAG_M values
+        MODE_USR        = 0x10,
+        MODE_FIQ        = 0x11,
+        MODE_IRQ        = 0x12,
+        MODE_SVC        = 0x13,
+        MODE_ABORT      = 0x17,
+        MODE_UNDEFINED  = 0x1b,
+        MODE_SYS        = 0x1f
+    };
+
+    // Exceptions
+    typedef Reg Exception_Id;
+    enum {
+        EXC_START                   = 1,
+        EXC_UNDEFINED_INSTRUCTION   = 2,
+        EXC_SWI                     = 3,
+        EXC_PREFETCH_ABORT          = 4,
+        EXC_DATA_ABORT              = 5,
+        EXC_RESERVED                = 6,
+        EXC_IRQ                     = 7,
+        EXC_FIQ                     = 8
+    };
+
+    enum {
+        CLI_DOMAIN = 0x55555555, // 0b01 - Client, all memory domains check for memory access permission
+        MNG_DOMAIN = 0xFFFFFFFF  // 0b11 - Manager, memory access permissions are not checked
+    };
+
+    // SCTLR bits
+    enum {
+        MMU_ENABLE  = 1 << 0,  // MMU enable
+        DCACHE      = 1 << 2,  // Data cache enable
+        BRANCH_PRED = 1 << 11, // Z bit, branch prediction enable
+        ICACHE      = 1 << 12, // Instruction cache enable
+        AFE         = 1 << 29  // Access Flag enable
+    };
+
+    // ACTLR bits
+    enum {
+        DCACHE_PREFE = 1 << 2, // DCache prefetch Enabled
+        SMP          = 1 << 6 // SMP bit
+    };
+
+    // CPU Context
+    class Context: public ARMv8::Context
+    {
+    public:
+        Context() {}
+        Context(Log_Addr entry, Log_Addr exit, Log_Addr usp): ARMv8::Context(usp, exit | thumb, multitask ? (usp ? MODE_USR : MODE_SVC) : MODE_SVC, exit | thumb, entry | thumb) {}
+    };
+
+protected:
+    ARMv8_A() {};
+
+public:
+    /*static Flags flags() { return cpsr(); }
+    static void flags(Flags flags) { cpsr(flags); }*/
+
+    static Flags flags() { return 0; }
+    static void flags(Flags flags) {}
+
+    static unsigned int id() {
+        Reg id = 0;
+        //ASM("mrc p15, 0, %0, c0, c0, 5" : "=r"(id) : : );
+        return id & 0x3;
+    }
+
+    static unsigned int cores() {
+        if(Traits<Build>::MODEL == Traits<Build>::Raspberry_Pi3) {
+            return Traits<Build>::CPUS;
+        } else {
+            Reg n = 0;
+            /*ASM("mrc p15, 4, %0, c15, c0, 0 \t\n\
+                 ldr %0, [%0, #0x004]" : "=r"(n) : : );*/
+            return (n & 0x3) + 1;
+        }
+    }
+
+    static void int_enable() {  flags(flags() & ~(FLAG_F | FLAG_I)); }
+    static void int_disable() { flags(flags() | (FLAG_F | FLAG_I)); }
+
+    static bool int_enabled() { return !int_disabled(); }
+    static bool int_disabled() { return flags() & (FLAG_F | FLAG_I); }
+
+    static void smp_barrier(unsigned long cores = cores()) { CPU_Common::smp_barrier<&finc>(cores, id()); }
+
+    static void fpu_save() {    ASM("vpush {s0-s15} \n vpush {s16-s31}"); }
+    static void fpu_restore() { ASM("vpop  {s0-s15} \n vpop  {s16-s31}"); }
+
+    // ARMv8-A specifics
+    /*static Reg cpsr() { Reg r; ASM("mrs %0, cpsr" : "=r"(r) : : ); return r; }
+    static void cpsr(Reg r) { ASM("msr cpsr, %0" : : "r"(r) : "cc"); }
+
+    static Reg cpsrc() { Reg r; ASM("mrs %0, cpsr_c" : "=r"(r) : : ); return r; }
+    static void cpsrc(Reg r) { ASM("msr cpsr_c, %0" : : "r"(r): ); }
+
+    static void psr_to_x12() { ASM("mrs x12, cpsr" : : : "x12"); }
+    static void x12_to_psr() { ASM("msr cpsr, x12" : : : "cc"); }*/
+
+    static Reg cpsr() { return 0; }
+    static void cpsr(Reg r) {}
+
+    static Reg cpsrc() { return 0; }
+    static void cpsrc(Reg r) {}
+
+    static void psr_to_x12() {}
+    static void x12_to_psr() {}
+
+    static void save_regs(bool ret = false) {
+        if(ret)
+            ASM("stmfd sp!, {x0-x3, x12, lr, pc}");
+        else
+            ASM("stmfd sp!, {x0-x3, x12, lr}");
+    }
+
+    static void restore_regs(bool ret = false) {
+        if(ret)
+            ASM("ldmfd   sp!, {x0-x3, x12, lr, pc}^");  // including PC in ldmfd cause a mode change to the mode given by PSR (the mode the CPU was before the interrupt)
+        else
+            ASM("ldmfd sp!, {x0-x3, x12, lr}");
+    }
+
+    static void mode(unsigned int m) { /*ASM("msr cpsr_c, %0" : : "i"(m | FLAG_F | FLAG_I) : "cc");*/ }
+
+    static void svc_enter(unsigned int from, bool ret = true) {
+        mode(MODE_SVC);                 // go to SVC mode to save context
+        save_regs(ret);                 // save current context (lr, sp and spsr are banked registers)
+        mode(from);                     // go back to mode "from" to recover LR and PSR
+        ASM("sub x1, lr, #4");          // x1 = return address when entering mode "from"
+        ASM("mrs x2, spsr");            // x2 = "from"_spsr (to be visible at SVC)
+        mode(MODE_SVC);                 // go to SVC mode once again
+        if(ret) {                       // if we will return, then
+            ASM("str x1, [sp, #24]");   // overwrite the saved PC with x1, which contains the recovered return address
+            ASM("push {x2}");           // push the recovered PSR
+        }
+        // upon return, x1 (LR) and x2 (PSR) are preserved and can be further used
+    }
+
+    static void svc_leave() {
+        ASM("pop {x2}");            // pop saved mode "from" PSR into SVC_spsr
+        ASM("msr spsr_cfxs, x2");
+        restore_regs(true);              // restore the context, eventually changing back to "from" mode and jumping to the saved return address
+    }
+
+    static void svc_stay() { restore_regs(false); }
+
+    static Reg elr_hyp() { Reg r; ASM("mrs %0, ELR_hyp" : "=r"(r) : : ); return r; }
+    static void elr_hyp(Reg r) { ASM("msr ELR_hyp, %0" : : "r"(r): ); }
+
+    static void ldmia() { /*ASM("ldmia x0!,{x2,x3,x4,x5,x6,x7,x8,x9}" : : : ); */}
+    static void stmia() { /*ASM("stmia x1!,{x2,x3,x4,x5,x6,x7,x8,x9}" : : : );*/ }
+
+    // CP15 operations
+    static Reg ttbr0() { Reg r; ASM ("mrs %0, ttbr0_el1" : "=r"(r) : :); return r; }
+    static void ttbr0(Reg r) {  ASM ("msr ttbr0_el1, %0" : : "p"(r) :); }
+
+    static Reg ttbcr() { Reg r; ASM ("mrs %0, vtcr_el2" : "=r"(r) : :); return r; }
+    static void ttbcr(Reg r) {  ASM ("msr vtcr_el2, %0" : : "p"(r) :); }
+
+    static Reg dacr() { Reg r; ASM ("mrs %0, dacr32_el2" : "=r"(r) : :); return r; }
+    static void dacr(Reg r) {  ASM ("msr dacr32_el2, %0" : : "p"(r) :); }
+
+    static Reg pd() { return ttbr0(); }
+    static void pd(Reg r) {  ttbr0(r); }
+
+    static void flush_tlb() {      /*ASM("mcr p15, 0, %0, c8, c7, 0" : : "r" (0));*/ } // TLBIALL - invalidate entire unifed TLB
+    static void flush_tlb(Reg r) { /*ASM("mcr p15, 0, %0, c8, c7, 0" : : "r" (r));*/ }
+
+    static void flush_branch_predictors() { /*ASM("mcr p15, 0, %0, c7, c5, 6" : : "r" (0));*/ }
+
+    static void flush_caches() {/*
+        ASM("// Disable L1 Caches                                                                       \t\n\
+             mrc     p15, 0, x1, c1, c0, 0      // read SCTLR                                           \t\n\
+             bic     x1, x1, #(0x1 << 2)        // disable D Cache                                      \t\n\
+             mcr     p15, 0, x1, c1, c0, 0      // write SCTLR                                          \t\n\
+                                                                                                        \t\n\
+             // Invalidate Data cache, calculating the cache size and looping through each set and way  \t\n\
+             mov     x0, #0x0                   // x0 = 0x0 for L1 dcache 0x2 for L2 dcache             \t\n\
+             mcr     p15, 2, x0, c0, c0, 0      // CSSELR cache size selection Register                 \t\n\
+             mrc     p15, 1, x4, c0, c0, 0      // CCSIDR read cache size                               \t\n\
+             and     x1, x4, #0x7                                                                       \t\n\
+             add     x1, x1, #0x4               // x1 = cache line size                                 \t\n\
+             ldr     x3, =0x7fff                                                                        \t\n\
+             and     x2, x3, x4, lsr #13        // x2 = cache set number - 1                            \t\n\
+             ldr     x3, =0x3ff                                                                         \t\n\
+             and     x3, x3, x4, lsr #3         // x3 = cache associativity number - 1                  \t\n\
+             clz     x4, x3                     // x4 = way position in CISW instruction                \t\n\
+             mov     x5, #0                     // x5 = way loop counter                                \t\n\
+         way_loop:                                                                                      \t\n\
+             mov     x6, #0                     // x6 = set loop counter                                \t\n\
+         set_loop:                                                                                      \t\n\
+             orr     x7, x0, x5, lsl x4         // set way                                              \t\n\
+             orr     x7, x7, x6, lsl x1         // set set                                              \t\n\
+             mcr     p15, 0, x7, c7, c6, 2      // DCCISW x7                                            \t\n\
+             add     x6, x6, #1                 // increment set counter                                \t\n\
+             cmp     x6, x2                     // last set reached?                                    \t\n\
+             ble     set_loop                   // if not, iterate set_loop                             \t\n\
+             add     x5, x5, #1                 // else, next way                                       \t\n\
+             cmp     x5, x3                     // last way reached?                                    \t\n\
+             ble     way_loop                   // if not, iterate way_loop                                  ");*/
+    }
+
+    static void enable_fpu() {/*
+        // This code assumes a compilation with mfloat-abi=hard and does not care for context switches
+        ASM("mrc     p15, 0, x0, c1, c0, 2                                              \t\n\
+             orr     x0, x0, #0x300000           // single precision                    \t\n\
+             orr     x0, x0, #0xc00000           // double precision                    \t\n\
+             mcr     p15, 0, x0, c1, c0, 2                                              \t\n\
+             mov     x0, #0x40000000                                                    \t\n\
+             fmxr    fpexc,x0                                                                ");*/
+    }
+
+};
+
+#ifndef __armv9_h
+
+class CPU: public SWITCH<Traits<Build>::MODEL, CASE<Traits<Build>::eMote3, ARMv8_M, CASE<Traits<Build>::LM3S811, ARMv8_M, CASE<DEFAULT, ARMv8_A>>>>::Result
+{
+    friend class Init_System;
+
+private:
+    typedef SWITCH<Traits<Build>::MODEL, CASE<Traits<Build>::eMote3, ARMv8_M, CASE<Traits<Build>::LM3S811, ARMv8_M, CASE<DEFAULT, ARMv8_A>>>>::Result Base;
+
+public:
+    // CPU Native Data Types
+    using ARMv8::Reg8;
+    using ARMv8::Reg16;
+    using ARMv8::Reg32;
+    using ARMv8::Reg64;
+    using ARMv8::Reg;
+    using ARMv8::Log_Addr;
+    using ARMv8::Phy_Addr;
+
+    // CPU Context
+    class Context: public Base::Context
+    {
+    public:
+        Context() {}
+        Context(Log_Addr entry, Log_Addr exit, Log_Addr usp): Base::Context(entry, exit, usp) {}
+
+        void save() volatile;
+        void load() const volatile;
+
+        friend Debug & operator<<(Debug & db, const Context & c) {
+            db << hex
+               << "{x0="  << c._x0
+               << ",x1="  << c._x1
+               << ",x2="  << c._x2
+               << ",x3="  << c._x3
+               << ",x4="  << c._x4
+               << ",x5="  << c._x5
+               << ",x6="  << c._x6
+               << ",x7="  << c._x7
+               << ",x8="  << c._x8
+               << ",x9="  << c._x9
+               << ",x10=" << c._x10
+               << ",x11=" << c._x11
+               << ",x12=" << c._x12
+               << ",sp="  << &c
+               << ",lr="  << c._lr
+               << ",pc="  << c._pc
+               << ",psr=" << c._flags
+               << ",usp=" << c._usp
+               << ",ulr=" << c._ulr
+               << "}" << dec;
+            return db;
+        }
+    };
+
+public:
+    CPU() {}
+
+    using ARMv8::pc;
+    using ARMv8::ra;
+    using ARMv8::sp;
+    using ARMv8::fr;
+
+    using Base::id;
+    using Base::cores;
+
+    static Hertz clock() { return _cpu_clock; }
+    static void clock(const Hertz & frequency); // defined along with each machine's IOCtrl
+    static Hertz max_clock();
+    static Hertz min_clock();
+    static Hertz bus_clock() { return _bus_clock; }
+
+    using Base::int_enable;
+    using Base::int_disable;
+    using Base::int_enabled;
+    using Base::int_disabled;
+
+    using ARMv8::halt;
+
+    using Base::fpu_save;
+    using Base::fpu_restore;
+
+    using ARMv8::tsl;
+    using ARMv8::finc;
+    using ARMv8::fdec;
+    using ARMv8::cas;
+
+    static void switch_context(Context ** o, Context * n);
+
+    template<typename ... Tn>
+    static Context * init_stack(Log_Addr usp, Log_Addr sp, void (* exit)(), int (* entry)(Tn ...), Tn ... an) {
+        sp -= sizeof(Context);
+        Context * ctx = new(sp) Context(entry, exit, usp); // init_stack is called with usp = 0 for kernel threads
+        init_stack_helper(&ctx->_x0, an ...);
+        return ctx;
+    }
+
+    // In ARMv8, the main thread of each task gets parameters over registers, not the stack, and they are initialized by init_stack.
+    template<typename ... Tn>
+    static Log_Addr init_user_stack(Log_Addr usp, void (* exit)(), Tn ... an) { return usp; }
+
+    static void syscall(void * message);
+    static void syscalled();
+
+    using CPU_Common::htole64;
+    using CPU_Common::htole32;
+    using CPU_Common::htole16;
+    using CPU_Common::letoh64;
+    using CPU_Common::letoh32;
+    using CPU_Common::letoh16;
+
+    using CPU_Common::htobe64;
+    using CPU_Common::htobe32;
+    using CPU_Common::htobe16;
+    using CPU_Common::betoh64;
+    using CPU_Common::betoh32;
+    using CPU_Common::betoh16;
+
+    using CPU_Common::htonl;
+    using CPU_Common::htons;
+    using CPU_Common::ntohl;
+    using CPU_Common::ntohs;
+
+private:
+    template<typename Head, typename ... Tail>
+    static void init_stack_helper(Log_Addr sp, Head head, Tail ... tail) {
+        *static_cast<Head *>(sp) = head;
+        init_stack_helper(sp + sizeof(Head), tail ...);
+    }
+    static void init_stack_helper(Log_Addr sp) {}
+
+    static void context_load_helper();
+
+    static void init();
+
+private:
+    static unsigned int _cpu_clock;
+    static unsigned int _bus_clock;
+};
+
+inline CPU::Reg64 htole64(CPU::Reg64 v) { return CPU::htole64(v); }
+inline CPU::Reg32 htole32(CPU::Reg32 v) { return CPU::htole32(v); }
+inline CPU::Reg16 htole16(CPU::Reg16 v) { return CPU::htole16(v); }
+inline CPU::Reg64 letoh64(CPU::Reg64 v) { return CPU::letoh64(v); }
+inline CPU::Reg32 letoh32(CPU::Reg32 v) { return CPU::letoh32(v); }
+inline CPU::Reg16 letoh16(CPU::Reg16 v) { return CPU::letoh16(v); }
+
+inline CPU::Reg64 htobe64(CPU::Reg64 v) { return CPU::htobe64(v); }
+inline CPU::Reg32 htobe32(CPU::Reg32 v) { return CPU::htobe32(v); }
+inline CPU::Reg16 htobe16(CPU::Reg16 v) { return CPU::htobe16(v); }
+inline CPU::Reg64 betoh64(CPU::Reg64 v) { return CPU::betoh64(v); }
+inline CPU::Reg32 betoh32(CPU::Reg32 v) { return CPU::betoh32(v); }
+inline CPU::Reg16 betoh16(CPU::Reg16 v) { return CPU::betoh16(v); }
+
+inline CPU::Reg32 htonl(CPU::Reg32 v)   { return CPU::htonl(v); }
+inline CPU::Reg16 htons(CPU::Reg16 v)   { return CPU::htons(v); }
+inline CPU::Reg32 ntohl(CPU::Reg32 v)   { return CPU::ntohl(v); }
+inline CPU::Reg16 ntohs(CPU::Reg16 v)   { return CPU::ntohs(v); }
+
+#endif
+
+__END_SYS
+
+#endif
diff --git a/include/architecture/armv8/armv8_mmu.h b/include/architecture/armv8/armv8_mmu.h
new file mode 100644
index 0000000..1ac9bf2
--- /dev/null
+++ b/include/architecture/armv8/armv8_mmu.h
@@ -0,0 +1,484 @@
+// EPOS ARMv8 MMU Mediator Declarations
+
+#ifndef __armv8_mmu_h
+#define __armv8_mmu_h
+
+#include <architecture/mmu.h>
+#include <system/memory_map.h>
+
+__BEGIN_SYS
+
+class ARMv8_MMU: public MMU_Common<12, 8, 12>
+{
+    friend class CPU;
+    friend class Setup;
+
+private:
+    typedef Grouping_List<Frame> List;
+
+    static const bool colorful = Traits<MMU>::colorful;
+    static const unsigned int COLORS = Traits<MMU>::COLORS;
+    static const unsigned int RAM_BASE = Memory_Map::RAM_BASE;
+    static const unsigned int APP_LOW = Memory_Map::APP_LOW;
+    static const unsigned int PHY_MEM = Memory_Map::PHY_MEM;
+    static const unsigned int SYS = Memory_Map::SYS;
+
+public:
+    // Page Flags
+    class Page_Flags
+    {
+    public:
+        // Page Table entry flags
+        enum {
+            XN   = 1 << 0,  // not executable
+            PTE  = 1 << 1,  // sets entry as Small Page == Page Table Entry
+            // Access Permission bits, assuming SCTLR.AFE = 0
+            AP0  = 1 << 4,  
+            AP1  = 1 << 5,
+            AP2  = 1 << 9,
+            RW   = AP0,     // Read Write SYS
+            RO   = AP2,     // Read only SYS
+            USR  = (AP1 | AP0),
+            // TEX[2:0], C, B, S --> set Shareability/Cacheability
+            B    = 1 << 2,  // Bufferable
+            C    = 1 << 3,  // Cacheable
+            TEX0 = 1 << 6,
+            TEX1 = 1 << 7,
+            TEX2 = 1 << 8,
+            S    = 1 << 10, // Shareable
+            nG   = 1 << 11, // Not Global
+
+            SDEV = B,       // Shareable Device Memory, should not be used along with CT or CWT
+            CD   = TEX2,    // Cache Disable
+            CWT  = (TEX2 | TEX1 | TEX0 | C | B),  // Cacheable Write Through
+
+            // Page Table flags
+            APP  = (nG | S | AP1 | AP0 | CWT | PTE),        // S, RWX  All, Normal WT
+            APPD = (nG | S | AP1 | AP0 | CWT | XN  | PTE),  // S, RWnX All, Normal WT
+            APPC = (nG | S | AP2 | AP1 | AP0 | CWT | PTE),  // S, RnWX All, Normal WT
+            SYS  = (nG | S | AP0 | CWT | PTE),              // S, RWX  SYS, Normal WT
+            IO   = (nG | AP0 | SDEV | PTE),                 // Device Memory = Shareable, RWX, SYS
+            DMA  = (nG | AP0 | SDEV | PTE),                 // Device Memory no cacheable / Old Peripheral = Shareable, RWX, B ?
+            PT_MASK = (1 << 12) - 1
+        };
+
+        // Short-descriptor format | Page Directory entry flags
+        enum {
+            PDE  = 1 << 0,         // Set descriptor as Page Directory entry
+            NS   = 1 << 3,         // NonSecure Memory Region
+            PD_FLAGS = (NS | PDE),
+            PD_MASK = (1 << 10) -1
+        };
+
+    public:
+        Page_Flags() {}
+        Page_Flags(unsigned int f) : _flags(f) {}
+        Page_Flags(Flags f) : _flags(nG |
+                                    ((f & Flags::RW)  ? RW   : RO) |
+                                    ((f & Flags::USR) ? USR  : 0) |
+                                    ((f & Flags::CWT) ? CWT  : 0) |
+                                    ((f & Flags::CD)  ? CD   : 0) |
+                                    ((f & Flags::EX)  ? 0    : XN) |
+                                    ((f & Flags::IO)  ? SDEV : S) ) {}
+
+        operator unsigned int() const { return _flags; }
+
+        friend Debug & operator<<(Debug & db, const Page_Flags & f) { db << hex << f._flags; return db; }
+
+    private:
+        unsigned int _flags;
+    };
+
+    // Page_Table
+    template<unsigned int ENTRIES>
+    class _Page_Table
+    {
+    public:
+        _Page_Table() {}
+
+        PT_Entry & operator[](unsigned int i) { return _entry[i]; }
+        _Page_Table & log() { return *static_cast<_Page_Table *>(phy2log(this)); }
+
+        void map(int from, int to, Page_Flags flags, Color color) {
+            Phy_Addr * addr = alloc(to - from, color);
+            if(addr)
+                remap(addr, from, to, flags);
+            else
+                for( ; from < to; from++) {
+                    Log_Addr * pte = phy2log(&_entry[from]);
+                    *pte = phy2pte(alloc(1, color), flags);
+                }
+        }
+
+        void map_contiguous(int from, int to, Page_Flags flags, Color color) {
+            remap(alloc(to - from, color), from, to, flags);
+        }
+
+        void remap(Phy_Addr addr, int from, int to, Page_Flags flags) {
+            addr = align_page(addr);
+            for( ; from < to; from++) {
+                Log_Addr * pte = phy2log(&_entry[from]);
+                *pte = phy2pte(addr, flags);
+                addr += sizeof(Page);
+            }
+        }
+
+        void unmap(int from, int to) {
+            for( ; from < to; from++) {
+                free(_entry[from]);
+                Log_Addr * pte = phy2log(&_entry[from]);
+                *pte = 0;
+            }
+        }
+
+        friend OStream & operator<<(OStream & os, _Page_Table & pt) {
+            os << "{\n";
+            int brk = 0;
+            for(unsigned int i = 0; i < ENTRIES; i++)
+                if(pt[i]) {
+                    os << "[" << i << "]=" << pt[i] << "  ";
+                    if(!(++brk % 4))
+                        os << "\n";
+                }
+            os << "\n}";
+            return os;
+        }
+
+    private:
+        PT_Entry _entry[ENTRIES]; // the Phy_Addr in each entry passed through phy2pte()
+    };
+
+    typedef _Page_Table<PT_ENTRIES> Page_Table;
+
+    // Page Directory
+    typedef _Page_Table<PD_ENTRIES> Page_Directory;
+
+    // Chunk (for Segment)
+    class Chunk
+    {
+    public:
+        Chunk() {}
+
+        Chunk(unsigned int bytes, Flags flags, Color color = WHITE)
+        : _from(0), _to(pages(bytes)), _pts(page_tables(_to - _from)), _flags(Page_Flags(flags)), _pt(calloc(_pts, WHITE)) {
+            if(!((_flags & Page_Flags::CWT) || (_flags & Page_Flags::CD))) // CT == Strongly Ordered == C/B/TEX bits are 0
+                _pt->map_contiguous(_from, _to, _flags, color);
+            else
+                _pt->map(_from, _to, _flags, color);
+        }
+
+        Chunk(Phy_Addr phy_addr, unsigned int bytes, Flags flags)
+        : _from(0), _to(pages(bytes)), _pts(page_tables(_to - _from)), _flags(Page_Flags(flags)), _pt(calloc(_pts, WHITE)) {
+            _pt->remap(phy_addr, _from, _to, flags);
+        }
+
+        Chunk(Phy_Addr pt, unsigned int from, unsigned int to, Flags flags)
+        : _from(from), _to(to), _pts(page_tables(_to - _from)), _flags(flags), _pt(pt) {}
+
+        ~Chunk() {
+            if(!(_flags & Page_Flags::IO)) {
+                if(!((_flags & Page_Flags::CWT) || (_flags & Page_Flags::CD))) // CT == Strongly Ordered == C/B/TEX bits are 0
+                    free((*_pt)[_from], _to - _from);
+                else
+                    for( ; _from < _to; _from++)
+                        free((*_pt)[_from]);
+            }
+            free(_pt, _pts);
+        }
+
+        unsigned int pts() const { return _pts; }
+        Page_Flags flags() const { return _flags; }
+        Page_Table * pt() const { return _pt; }
+        unsigned int size() const { return (_to - _from) * sizeof(Page); }
+
+        Phy_Addr phy_address() const {
+            return (!((_flags & Page_Flags::CWT) || (_flags & Page_Flags::CD))) ? Phy_Addr(indexes((*_pt)[_from])) : Phy_Addr(false);
+            // CT == Strongly Ordered == C/B/TEX bits are 0
+        }
+
+        int resize(unsigned int amount) {
+            if(!((_flags & Page_Flags::CWT) || (_flags & Page_Flags::CD))) // CT == Strongly Ordered == C/B/TEX bits are 0
+                return 0;
+
+            unsigned int pgs = pages(amount);
+
+            Color color = colorful ? phy2color(_pt) : WHITE;
+
+            unsigned int free_pgs = _pts * PT_ENTRIES - _to;
+            if(free_pgs < pgs) { // resize _pt
+                unsigned int pts = _pts + page_tables(pgs - free_pgs);
+                Page_Table * pt = calloc(pts, color);
+                memcpy(phy2log(pt), phy2log(_pt), _pts * sizeof(Page));
+                free(_pt, _pts);
+                _pt = pt;
+                _pts = pts;
+            }
+
+            _pt->map(_to, _to + pgs, _flags, color);
+            _to += pgs;
+
+            return pgs * sizeof(Page);
+        }
+
+    private:
+        unsigned int _from;
+        unsigned int _to;
+        unsigned int _pts;
+        Page_Flags _flags;
+        Page_Table * _pt; // this is a physical address
+    };
+
+    // Directory (for Address_Space)
+    class Directory
+    {
+    public:
+        Directory() : _free(true) {
+            // Page Directories have 4096 32-bit entries and must be aligned to 16Kb, thus, we need 7 frame in the worst case
+            Phy_Addr pd = calloc(sizeof(Page_Directory) / sizeof(Frame) + ((sizeof(Page_Directory) / sizeof(Frame)) - 1), WHITE);
+            unsigned int free_frames = 0;
+            while(pd & (sizeof(Page_Directory) - 1)) { // pd is not aligned to 16 Kb
+                Phy_Addr * tmp = pd;
+                pd += sizeof(Frame); // skip this frame
+                free(tmp); // return this frame to the free list
+                free_frames++;
+            }
+            if(free_frames != 3)
+                free(pd + 4 * sizeof(Page), 3 - free_frames); // return exceeding frames at the tail to the free list
+
+            _pd = static_cast<Page_Directory *>(pd);
+
+            for(unsigned int i = directory(PHY_MEM); i < directory(APP_LOW); i++)
+                (*_pd)[i] = (*_master)[i];
+            
+            for(unsigned int i = directory(SYS); i < PD_ENTRIES; i++)
+                (*_pd)[i] = (*_master)[i];
+        }
+
+        Directory(Page_Directory * pd) : _pd(pd), _free(false) {}
+
+        ~Directory() { if(_free) free(_pd, sizeof(Page_Directory) / sizeof(Page)); }
+
+        Phy_Addr pd() const { return _pd; }
+
+        void activate() const { ARMv8_MMU::pd(_pd); }
+
+        Log_Addr attach(const Chunk & chunk, unsigned int from = directory(APP_LOW)) {
+            for(unsigned int i = from; i < directory(SYS); i++)
+                if(attach(i, chunk.pt(), chunk.pts(), chunk.flags()))
+                    return i << DIRECTORY_SHIFT;
+            return Log_Addr(false);
+        }
+
+        Log_Addr attach(const Chunk & chunk, Log_Addr addr) {
+            unsigned int from = directory(addr);
+            if(attach(from, chunk.pt(), chunk.pts(), chunk.flags()))
+                return from << DIRECTORY_SHIFT;
+            return Log_Addr(false);
+        }
+
+        void detach(const Chunk & chunk) {
+            for(unsigned int i = 0; i < PD_ENTRIES; i++) {
+                if(indexes(pte2phy((*_pd)[i])) == indexes(chunk.pt())) {
+                    detach(i, chunk.pt(), chunk.pts());
+                    return;
+                }
+            }
+            db<MMU>(WRN) << "MMU::Directory::detach(pt=" << chunk.pt() << ") failed!" << endl;
+        }
+
+        void detach(const Chunk & chunk, Log_Addr addr) {
+            unsigned int from = directory(addr);
+            if(indexes(pte2phy((*_pd)[from])) != indexes(chunk.pt())) {
+                db<MMU>(WRN) << "MMU::Directory::detach(pt=" << chunk.pt() << ",addr=" << addr << ") failed!" << endl;
+                return;
+            }
+            detach(from, chunk.pt(), chunk.pts());
+        }
+
+        Phy_Addr physical(Log_Addr addr) {
+            PD_Entry pde = (*_pd)[directory(addr)];
+            Page_Table * pt = static_cast<Page_Table *>(pde2phy(pde));
+            PT_Entry pte = pt->log()[page(addr)];
+            return pte | offset(addr);
+        }
+
+    private:
+        bool attach(unsigned int from, const Page_Table * pt, unsigned int n, Page_Flags flags) {
+            for(unsigned int i = from; i < from + n; i++)
+                if(_pd->log()[i])
+                    return false;
+            for(unsigned int i = from; i < from + n; i++, pt++)
+                _pd->log()[i] = phy2pde(Phy_Addr(pt));
+            return true;
+        }
+
+        void detach(unsigned int from, const Page_Table * pt, unsigned int n) {
+            for(unsigned int i = from; i < from + n; i++) {
+                _pd->log()[i] = 0;
+                flush_tlb(i << DIRECTORY_SHIFT);
+            }
+            CPU::isb();
+            CPU::dsb();
+        }
+
+    private:
+        Page_Directory * _pd;  // this is a physical address, but operator*() returns a logical address
+        bool _free;
+    };
+
+   // DMA_Buffer
+    class DMA_Buffer: public Chunk
+    {
+    public:
+        DMA_Buffer(unsigned int s) : Chunk(s, Page_Flags::DMA) {
+            Directory dir(current());
+            _log_addr = dir.attach(*this);
+            db<MMU>(TRC) << "MMU::DMA_Buffer() => " << *this << endl;
+        }
+
+        DMA_Buffer(unsigned int s, Log_Addr d): Chunk(s, Page_Flags::DMA) {
+            Directory dir(current());
+            _log_addr = dir.attach(*this);
+            memcpy(_log_addr, d, s);
+            db<MMU>(TRC) << "MMU::DMA_Buffer(phy=" << *this << " <= " << d << endl;
+        }
+
+        Log_Addr log_address() const { return _log_addr; }
+
+        friend OStream & operator<<(OStream & os, const DMA_Buffer & b) {
+            os << "{phy=" << b.phy_address() << ",log=" << b.log_address() << ",size=" << b.size() << ",flags=" << b.flags() << "}";
+            return os;
+        }
+
+    private:
+        Log_Addr _log_addr;
+    };
+
+    // Class Translation performs manual logical to physical address translations for debugging purposes only
+    class Translation
+    {
+    public:
+        Translation(Log_Addr addr, bool pt = false, Page_Directory * pd = 0): _addr(addr), _show_pt(pt), _pd(pd) {}
+
+        friend OStream & operator<<(OStream & os, const Translation & t) {
+            Page_Directory * pd = t._pd ? t._pd : current();
+            PD_Entry pde = pd->log()[directory(t._addr)];
+            Page_Table * pt = static_cast<Page_Table *>(pde2phy(pde));
+            PT_Entry pte = pt->log()[page(t._addr)];
+
+            os << "{addr=" << static_cast<void *>(t._addr) << ",pd=" << pd << ",pd[" << directory(t._addr) << "]=" << pde << ",pt=" << pt;
+            if(t._show_pt)
+                os << "=>" << pt->log();
+            os << ",pt[" << page(t._addr) << "]=" << pte << ",f=" << pte2phy(pte) << ",*addr=" << hex << *static_cast<unsigned int *>(t._addr) << "}";
+            return os;
+        }
+
+    private:
+        Log_Addr _addr;
+        bool _show_pt;
+        Page_Directory * _pd;
+    };
+
+public:
+    ARMv8_MMU() {}
+
+    static Phy_Addr alloc(unsigned int frames = 1, Color color = WHITE) {
+        Phy_Addr phy(false);
+
+        if(frames) {
+            List::Element * e = _free[color].search_decrementing(frames);
+            if(e) {
+                phy = e->object() + e->size();
+                db<MMU>(TRC) << "MMU::alloc(frames=" << frames << ",color=" << color << ") => " << phy << endl;
+            } else
+                if(colorful)
+                    db<MMU>(INF) << "MMU::alloc(frames=" << frames << ",color=" << color << ") => failed!" << endl;
+                else
+                    db<MMU>(WRN) << "MMU::alloc(frames=" << frames << ",color=" << color << ") => failed!" << endl;
+        }
+
+        return phy;
+    }
+
+    static Phy_Addr calloc(unsigned int frames = 1, Color color = WHITE) {
+        Phy_Addr phy = alloc(frames, color);
+        memset(phy2log(phy), 0, sizeof(Frame) * frames);
+        return phy;
+    }
+
+    static void free(Phy_Addr frame, int n = 1) {
+        // Clean up MMU flags in frame address
+        frame = indexes(frame);
+        Color color = colorful ? phy2color(frame) : WHITE;
+
+        db<MMU>(TRC) << "MMU::free(frame=" << frame << ",color=" << color << ",n=" << n << ")" << endl;
+
+        if(frame && n) {
+            List::Element * e = new (phy2log(frame)) List::Element(frame, n);
+            List::Element * m1, * m2;
+            _free[color].insert_merging(e, &m1, &m2);
+        }
+    }
+
+    static void white_free(Phy_Addr frame, int n) {
+        // Clean up MMU flags in frame address
+        frame = indexes(frame);
+
+        db<MMU>(TRC) << "MMU::free(frame=" << frame << ",color=" << WHITE << ",n=" << n << ")" << endl;
+
+        if(frame && n) {
+            List::Element * e = new (phy2log(frame)) List::Element(frame, n);
+            List::Element * m1, * m2;
+            _free[WHITE].insert_merging(e, &m1, &m2);
+        }
+    }
+
+    static unsigned int allocable(Color color = WHITE) { return _free[color].head() ? _free[color].head()->size() : 0; }
+
+    static Page_Directory * volatile current() { return static_cast<Page_Directory * volatile>(pd());}
+
+    static Phy_Addr physical(Log_Addr addr) {
+        Page_Directory * pd = current();
+        Page_Table * pt = pd->log()[directory(addr)];
+        return pt->log()[page(addr)] | offset(addr);
+    }
+
+    static PT_Entry phy2pte(Phy_Addr frame, Page_Flags flags) { return (frame) | flags | Page_Flags::PTE; }
+    static Phy_Addr pte2phy(PT_Entry entry) { return (entry & ~Page_Flags::PT_MASK); }
+    static PD_Entry phy2pde(Phy_Addr frame) { return (frame) | Page_Flags::PD_FLAGS; }
+    static Phy_Addr pde2phy(PD_Entry entry) { return (entry & ~Page_Flags::PD_MASK); }
+
+    static Log_Addr phy2log(Phy_Addr phy) { return Log_Addr((RAM_BASE == PHY_MEM) ? phy : (RAM_BASE > PHY_MEM) ? phy - (RAM_BASE - PHY_MEM) : phy + (PHY_MEM - RAM_BASE)); }
+    static Phy_Addr log2phy(Log_Addr log) { return Phy_Addr((RAM_BASE == PHY_MEM) ? log : (RAM_BASE > PHY_MEM) ? log + (RAM_BASE - PHY_MEM) : log - (PHY_MEM - RAM_BASE)); }
+
+    static Color phy2color(Phy_Addr phy) { return static_cast<Color>(colorful ? ((phy >> PAGE_SHIFT) & 0x7f) % COLORS : WHITE); } // TODO: what is 0x7f
+
+    static Color log2color(Log_Addr log) {
+        if(colorful) {
+            Page_Directory * pd = current();
+            Page_Table * pt = (*pd)[directory(log)];
+            Phy_Addr phy = (*pt)[page(log)] | offset(log);
+            return static_cast<Color>(((phy >> PAGE_SHIFT) & 0x7f) % COLORS);
+        } else
+            return WHITE;
+    }
+
+private:
+    static Phy_Addr pd() { return CPU::pd(); }
+    static void pd(Phy_Addr pd) { CPU::pd(pd); CPU::flush_tlb(); CPU::isb(); CPU::dsb(); }
+
+    static void flush_tlb() { CPU::flush_tlb(); }
+    static void flush_tlb(Log_Addr addr) { CPU::flush_tlb(directory_bits(addr)); } // only bits from 31 to 12, all ASIDs
+
+    static void init();
+
+private:
+    static List _free[colorful * COLORS + 1]; // +1 for WHITE
+    static Page_Directory * _master;
+};
+
+class MMU: public IF<Traits<System>::multitask, ARMv8_MMU, No_MMU>::Result {};
+
+__END_SYS
+
+#endif
diff --git a/include/architecture/armv8/armv8_pmu.h b/include/architecture/armv8/armv8_pmu.h
new file mode 100644
index 0000000..8f5a8ee
--- /dev/null
+++ b/include/architecture/armv8/armv8_pmu.h
@@ -0,0 +1,242 @@
+// EPOS ARMv8 PMU Mediator Declarations
+
+#ifndef __armv8_pmu_h
+#define __armv8_pmu_h
+
+#include <architecture/cpu.h>
+#define __common_only__
+#include <architecture/pmu.h>
+#undef __common_only__
+
+__BEGIN_SYS
+
+class ARMv8_A_PMU: public PMU_Common
+{
+private:
+    typedef CPU::Reg32 Reg32;
+
+protected:
+    static const unsigned int CHANNELS = 6;
+    static const unsigned int FIXED = 0;
+    static const unsigned int EVENTS = 93; // 54 if A53
+
+public:
+    // Useful bits in the PMCR register
+    enum {                      // Description                          Type    Value after reset
+        PMCR_E = 1 << 0,        // Enable all counters                  r/w
+        PMCR_P = 1 << 1,        // Reset event counters                 r/w
+        PMCR_C = 1 << 2,        // Cycle counter reset                  r/w
+        PMCR_D = 1 << 3,        // Enable cycle counter prescale (1/64) r/w
+        PMCR_X = 1 << 4,        // Export events                        r/w
+    };
+
+    // Useful bits in the PMCNTENSET register
+    enum {                      // Description                          Type    Value after reset
+        PMCNTENSET_C = 1 << 31, // Cycle counter enable                 r/w
+    };
+
+    // Useful bits in the PMOVSR register
+    enum {                      // Description                          Type    Value after reset
+        PMOVSR_C = 1 << 31,     // Cycle counter overflow clear         r/w
+    };
+
+    // Predefined architectural performance events
+    enum {
+        // Event
+        L1I_REFILL                            = 0x01,
+        L1I_TLB_REFILL                        = 0x02,
+        L1D_REFILL                            = 0x03,
+        L1D_ACCESS                            = 0x04,
+        L1D_TLB_REFILL                        = 0x05,
+        INSTRUCTIONS_ARCHITECTURALLY_EXECUTED = 0x08,
+        EXCEPTION_TAKEN                       = 0x09,
+        BRANCHES_ARCHITECTURALLY_EXECUTED     = 0x0c,
+        IMMEDIATE_BRANCH                      = 0X0d,
+        UNALIGNED_LOAD_STORE                  = 0X0f,
+        MISPREDICTED_BRANCH                   = 0x10,
+        CYCLE                                 = 0x11,
+        PREDICTABLE_BRANCH_EXECUTED           = 0x12,
+        DATA_MEMORY_ACCESS                    = 0x13,
+        L1I_ACCESS                            = 0x14,
+        L1D_WRITEBACK                         = 0x15,
+        L2D_ACCESS                            = 0x16,
+        L2D_REFILL                            = 0x17,
+        L2D_WRITEBACK                         = 0x18,
+        BUS_ACCESS                            = 0x19,
+        LOCAL_MEMORY_ERROR                    = 0x1a,
+        INSTRUCTION_SPECULATIVELY_EXECUTED    = 0x1b,
+        BUS_CYCLE                             = 0x1d,
+        CHAIN                                 = 0x1e,
+        // Cortex-A9 specific events
+        JAVA_BYTECODE_EXECUTE                 = 0x40,
+        SOFTWARE_JAVA_BYTECODE_EXECUTED       = 0x41,
+        JAZELLE_BACKWARDS_BRANCHES_EXECUTED   = 0x42,
+        COHERENT_LINEFILL_MISS                = 0x50,
+        COHERENT_LINEFILL_HIT                 = 0x51,
+        ICACHE_DEPENDENT_STALL_CYCLES         = 0x60,
+        DCACHE_DEPENDENT_STALL_CYCLES         = 0x61,
+        MAIN_TLB_MISS_STALL_CYCLES            = 0x62,
+        STREX_PASSED                          = 0x63,
+        STREX_FAILED                          = 0x64,
+        DATA_EVICTION                         = 0x65,
+        ISSUE_DOESNT_DISPATCH                 = 0x66,
+        ISSUE_EMPTY                           = 0x67,
+        ISSUE_CORE_RENAMING                   = 0x68,
+        PREDICTABLE_FUNCTION_RETURNS          = 0x6e,
+        MAIN_EXECUTION_UNIT_RETURNS           = 0x70,
+        SECOND_EXECUTION_UNIT_RETURNS         = 0x71,
+        LOAD_STORE_INSTRUCTIONS               = 0x72,
+        FLOATING_POINT_INSTRUCTIONS           = 0x73,
+        NEON_INSTRUCTIONS                     = 0x74,
+        PROCESSOR_STALL_PLD                   = 0x80,
+        PROCESSOR_STALL_WRITE_MEMORY          = 0x81,
+        PROCESSOR_STALL_ITLB_MISS             = 0x82,
+        PROCESSOR_STALL_DTLB_MISS             = 0x83,
+        PROCESSOR_STALL_IUTLB_MISS            = 0x84,
+        PROCESSOR_STALL_DUTLB_MISS            = 0x85,
+        PROCESSOR_STALL_DMB                   = 0x86,
+        INTEGER_CLOCK_ENABLED                 = 0x8a,
+        DATA_ENGINE_CLOCK_ENABLED             = 0x8b,
+        ISB_INSTRUCTIONS                      = 0x90,
+        DSB_INSTRUCTIONS                      = 0x91,
+        DMB_INSTRUCTIONS                      = 0x92,
+        EXTERNAL_INTERRUPTS                   = 0x93,
+        PLE_CACHE_LINE_REQUEST_COMPLETED      = 0xa0,
+        PLE_CACHE_LINE_REQUEST_SKIPPED        = 0xa1,
+        PLE_FIFO_FLUSH                        = 0xa2,
+        PLE_REQUEST_COMPLETED                 = 0xa3,
+        PLE_FIFO_OVERFLOW                     = 0xa4,
+        PLE_REQUEST_PROGRAMMED                = 0xa5,
+        // Cortex A-53 specific events
+        BUS_ACCESS_LD                         = 0x60,
+        BUS_ACCESS_ST                         = 0x61,
+        BR_INDIRECT_SPEC                      = 0x7a,
+        EXC_IRQ                               = 0x86,
+        EXC_FIQ                               = 0x87,
+        EXTERNAL_MEM_REQUEST                  = 0xc0,
+        EXTERNAL_MEM_REQUEST_NON_CACHEABLE    = 0xc1,
+        PREFETCH_LINEFILL                     = 0xc2,
+        ICACHE_THROTTLE                       = 0xc3,
+        ENTER_READ_ALLOC_MODE                 = 0xc4,
+        READ_ALLOC_MODE                       = 0xc5,
+        PRE_DECODE_ERROR                      = 0xc6,
+        DATA_WRITE_STALL_ST_BUFFER_FULL       = 0xc7,
+        SCU_SNOOPED_DATA_FROM_OTHER_CPU       = 0xc8,
+        CONDITIONAL_BRANCH_EXECUTED           = 0xc9,
+        IND_BR_MISP                           = 0xca,
+        IND_BR_MISP_ADDRESS_MISCOMPARE        = 0xcb,
+        CONDITIONAL_BRANCH_MISP               = 0xcc,
+        L1_ICACHE_MEM_ERROR                   = 0xd0,
+        L1_DCACHE_MEM_ERROR                   = 0xd1,
+        TLB_MEM_ERROR                         = 0xd2,
+        EMPTY_DPU_IQ_NOT_GUILTY               = 0xe0,
+        EMPTY_DPU_IQ_ICACHE_MISS              = 0xe1,
+        EMPTY_DPU_IQ_IMICRO_TLB_MISS          = 0xe2,
+        EMPTY_DPU_IQ_PRE_DECODE_ERROR         = 0xe3,
+        INTERLOCK_CYCLE_NOT_GUILTY            = 0xe4,
+        INTERLOCK_CYCLE_LD_ST_WAIT_AGU_ADDRESS= 0xe5,
+        INTERLOCK_CYCLE_ADV_SIMD_FP_INST      = 0xe6,
+        INTERLOCK_CYCLE_WR_STAGE_STALL_BC_MISS= 0xe7,
+        INTERLOCK_CYCLE_WR_STAGE_STALL_BC_STR = 0xe8,
+    };
+
+public:
+    ARMv8_A_PMU() {}
+
+    static void config(Channel channel, const Event event, Flags flags = NONE) {
+        assert((static_cast<unsigned int>(channel) < CHANNELS) && (static_cast<unsigned int>(event) < EVENTS));
+        db<PMU>(TRC) << "PMU::config(c=" << channel << ",e=" << event << ",f=" << flags << ")" << endl;
+        pmselr(channel);
+        pmxevtyper(_events[event]);
+        start(channel);
+    }
+
+    static Count read(Channel channel) {
+        db<PMU>(TRC) << "PMU::read(c=" << channel << ")" << endl;
+        pmselr(channel);
+        return pmxevcntr();
+    }
+
+    static void write(Channel channel, Count count) {
+        db<PMU>(TRC) << "PMU::write(ch=" << channel << ",ct=" << count << ")" << endl;
+        pmselr(channel);
+        pmxevcntr(count);
+    }
+
+    static void start(Channel channel) {
+        db<PMU>(TRC) << "PMU::start(c=" << channel << ")" << endl;
+        pmcntenset(pmcntenset() | (1 << channel));
+    }
+
+    static void stop(Channel channel) {
+        db<PMU>(TRC) << "PMU::stop(c=" << channel << ")" << endl;
+        pmcntenclr(pmcntenclr() | (1 << channel));
+    }
+
+    static void reset(Channel channel) {
+        db<PMU>(TRC) << "PMU::reset(c=" << channel << ")" << endl;
+        write(channel, 0);
+    }
+
+    static void init();
+
+private:
+    static void pmcr(Reg32 reg) { ASM("msr pmcr_el0, %0\n\t" : : "r"(reg)); }
+    static Reg32 pmcr() { Reg32 reg; ASM("mrs %0, pmcr_el0\n\t" : "=r"(reg) : ); return reg; }
+
+    static void pmcntenset(Reg32 reg) { ASM("msr pmcntenset_el0, %0\n\t" : : "r"(reg)); }
+    static Reg32 pmcntenset() { Reg32 reg; ASM("mrs %0, pmcntenset_el0\n\t" : "=r"(reg) : ); return reg; }
+
+    static void pmcntenclr(Reg32 reg) { ASM("msr pmcntenclr_el0, %0\n\t" : : "r"(reg)); }
+    static Reg32 pmcntenclr() { Reg32 reg; ASM("mrs %0, pmcntenclr_el0\n\t" : "=r"(reg) : ); return reg; }
+
+    static void pmovsr(Reg32 reg) { ASM("msr PMOVSSET_EL0, %0\n\t" : : "r"(reg)); }
+    static Reg32 pmovsr() { Reg32 reg; ASM("mrs %0, PMOVSSET_EL0\n\t" : "=r"(reg) : ); return reg; }
+
+    static void pmselr(Reg32 reg) { ASM("mrs pmselr_el0, %0\n\t" : : "r"(reg)); }
+    static Reg32 pmselr() { Reg32 reg; ASM("msr %0, pmselr_el0\n\t" : "=r"(reg) : ); return reg; }
+
+    static void pmxevtyper(const Reg32 reg) { ASM("msr pmxevtyper_el0, %0\n\t" : : "r"(reg)); }
+    static Reg32 pmxevtyper() { Reg32 reg; ASM("mrs %0, pmxevtyper_el0\n\t" : "=r"(reg) : ); return reg; }
+
+    static void pmxevcntr(Reg32 reg) { ASM("msr pmxevcntr_el0, %0\n\t" : : "r"(reg)); }
+    static Reg32 pmxevcntr() { Reg32 reg; ASM("mrs %0, pmxevcntr_el0\n\t" : "=r"(reg) : ); return reg; }
+
+private:
+    static const Event _events[EVENTS];
+};
+
+
+class PMU: private ARMv8_A_PMU
+{
+    friend class CPU;
+
+private:
+    typedef ARMv8_A_PMU Engine;
+
+public:
+    using Engine::CHANNELS;
+    using Engine::FIXED;
+    using Engine::EVENTS;
+
+    using Engine::Event;
+    using Engine::Count;
+    using Engine::Channel;
+
+public:
+    PMU() {}
+
+    using Engine::config;
+    using Engine::read;
+    using Engine::write;
+    using Engine::start;
+    using Engine::stop;
+    using Engine::reset;
+
+private:
+    static void init() { Engine::init(); }
+};
+
+__END_SYS
+
+#endif
diff --git a/include/architecture/armv8/armv8_traits.h b/include/architecture/armv8/armv8_traits.h
new file mode 100644
index 0000000..80cd153
--- /dev/null
+++ b/include/architecture/armv8/armv8_traits.h
@@ -0,0 +1,51 @@
+// EPOS ARMv8 Architecture Metainfo
+#ifndef __armv8_traits_h
+#define __armv8_traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+template<> struct Traits<CPU>: public Traits<Build>
+{
+    enum {LITTLE, BIG};
+    static const unsigned int ENDIANESS         = LITTLE;
+    static const unsigned int WORD_SIZE         = 64;
+    static const unsigned int CLOCK             = Traits<Build>::MODEL == Traits<Build>::LM3S811 ? 50000000 : Traits<Build>::MODEL == Traits<Build>::Zynq ? 666666687 : 32000000;
+    static const bool unaligned_memory_access   = false;
+};
+
+template<> struct Traits<MMU>: public Traits<Build>
+{
+    static const bool colorful = false;
+    static const unsigned int COLORS = 1;
+};
+
+template<> struct Traits<FPU>: public Traits<Build>
+{
+    static const bool enabled = (Traits<Build>::MODEL == Traits<Build>::Raspberry_Pi3);;
+    static const bool user_save = true;
+};
+
+template<> struct Traits<TSC>: public Traits<Build>
+{
+    // In order to use Machine::delay, TSC must be enabled
+    // On eMote3, TSC uses User_Timer on channel 3. To use channel 3, you must disable the TSC
+    // On LM3S811:
+    // * TSC uses User_Timer on channel 1. To use channel 1, you must disable the TSC
+    // * LM3S811 does not support up-count mode on general purpose timers,
+    //   and QEMU (v2.7.50) does not support reading the value of general purpose timers,
+    //   thus TSC::time_stamp() does not work, but Machine::delay does.
+    static const bool enabled = (Traits<Build>::MODEL != Traits<Build>::LM3S811);
+
+    // TODO: http://stackoverflow.com/questions/16236460/arm-cortex-a9-event-counters-return-0
+};
+
+template<> struct Traits<PMU>: public Traits<Build>
+{
+    static const bool enabled = (Traits<Build>::MODEL == Traits<Build>::Raspberry_Pi3);
+};
+
+__END_SYS
+
+#endif
diff --git a/include/architecture/armv8/armv8_tsc.h b/include/architecture/armv8/armv8_tsc.h
new file mode 100644
index 0000000..0d099b1
--- /dev/null
+++ b/include/architecture/armv8/armv8_tsc.h
@@ -0,0 +1,111 @@
+// EPOS ARMv8 Time-Stamp Counter Mediator Declarations
+
+#ifndef __armv8_tsc_h
+#define __armv8_tsc_h
+
+#include <architecture/cpu.h>
+#include <architecture/tsc.h>
+#include <system/memory_map.h>
+
+#define __ic_common_only__
+#include <machine/ic.h>
+#undef __ic_common_only__
+
+__BEGIN_SYS
+
+class TSC: private TSC_Common
+{
+    friend class CPU;
+    friend class IC;
+
+private:
+    static const Hertz CLOCK = Traits<Build>::MODEL == Traits<Build>::Raspberry_Pi3 ? 1000000 
+                             : Traits<Build>::MODEL == Traits<Build>::Zynq ? Traits<CPU>::CLOCK / 2
+                             : Traits<CPU>::CLOCK;
+    static const PPB ACCURACY = 40000; // ppb
+
+    // Cortex-M3 GPTM registers offsets
+    enum {              // Description
+        GPTMTAR = 0x48, // Counter
+    };
+
+    // Zynq Global Timer Registers offsets
+    enum {             // Description
+        GTCTRL = 0x00, // Low Counter
+        GTCTRH = 0x04, // High Counter
+        GTCLR  = 0x08, // Control
+        GTISR  = 0x0C  // Interrupt Status
+    };
+
+    // BCM2835 cortex-a53 System Timer
+    enum {                                      // Description
+        STCS                        = 0x00,     // Control/Status
+        STCLO                       = 0x04,     // Low COUNTER
+        STCHI                       = 0x08,     // High Counter
+        STC0                        = 0x0C,     // Compare 0 - Used by GPU
+        STC1                        = 0x10,     // Compare 1 - Value used to generate interrupt 1
+        STC2                        = 0X14,     // Compare 2 - Used by GPU
+        STC3                        = 0X18      // Compare 3 - Value used to generate interrupt 3
+        // Interrupts mapped to "Enable IRQ 1" - c1 and c3 == irq1 and irq3
+    };
+
+public:
+    using TSC_Common::Time_Stamp;
+
+    static const unsigned int FREQUENCY = CLOCK;
+
+public:
+    TSC() {}
+
+    static Hertz frequency() { return CLOCK; }
+    static PPB accuracy() { return ACCURACY; }
+
+    static Time_Stamp time_stamp() {
+
+#ifdef __cortex_a__
+
+#if defined(__mmod_raspberry_pi3__)
+        return reg(STCLO);
+#else
+        if(sizeof(Time_Stamp) == sizeof(CPU::Reg32))
+            return reg(GTCTRL);
+
+        Time_Stamp high;
+        CPU::Reg32 low;
+
+        do {
+            high = reg(GTCTRH);
+            low = reg(GTCTRL);
+        } while(reg(GTCTRH) != high);
+
+        return (high << 32) | low;
+
+#endif
+
+#endif
+#ifdef __cortex_m__
+
+        return (_overflow << 32) + reg(GPTMTAR); // Not supported by LM3S811 on QEMU (version 2.7.50)
+
+#endif
+
+    }
+
+private:
+    static void init();
+
+    static volatile CPU::Reg32 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg32 *>(Memory_Map::TSC_BASE)[o / sizeof(CPU::Reg32)]; }
+
+#if defined(__mmod_emote3__) || defined(__mmod_lm3s811__)
+
+    static void int_handler(IC_Common::Interrupt_Id int_id) { _overflow++; }
+
+    static volatile Time_Stamp _overflow;
+
+#endif
+
+};
+
+__END_SYS
+
+#endif
diff --git a/include/architecture/mmu.h b/include/architecture/mmu.h
index 17ea7d9..d2dd892 100644
--- a/include/architecture/mmu.h
+++ b/include/architecture/mmu.h
@@ -190,7 +190,7 @@ public:
         if(bytes) {
             List::Element * e = _free.search_decrementing(bytes);
             if(e)
-                phy = reinterpret_cast<unsigned int>(e->object()) + e->size();
+                phy = reinterpret_cast<unsigned long>(e->object()) + e->size();
             else
                 db<MMU>(ERR) << "MMU::alloc() failed!" << endl;
         }
diff --git a/include/machine/cortex/cortex_ic.h b/include/machine/cortex/cortex_ic.h
index b588a6f..ad5203a 100644
--- a/include/machine/cortex/cortex_ic.h
+++ b/include/machine/cortex/cortex_ic.h
@@ -93,13 +93,13 @@ private:
     static void hard_fault(Interrupt_Id i);
 
     // Physical handler
-    static void entry() __attribute__ ((naked));
-    static void prefetch_abort() __attribute__ ((naked));
-    static void undefined_instruction() __attribute__ ((naked));
-    static void software_interrupt() __attribute__ ((naked));
-    static void data_abort() __attribute__ ((naked));
-    static void reserved() __attribute__ ((naked));
-    static void fiq() __attribute__ ((naked));
+    static void entry();
+    static void prefetch_abort();
+    static void undefined_instruction();
+    static void software_interrupt();
+    static void data_abort();
+    static void reserved();
+    static void fiq();
 
     static void kill();
 
diff --git a/include/machine/cortex/engine/cortex_a53/bcm_mailbox.h b/include/machine/cortex/engine/cortex_a53/bcm_mailbox.h
index bb192e8..16dd04b 100644
--- a/include/machine/cortex/engine/cortex_a53/bcm_mailbox.h
+++ b/include/machine/cortex/engine/cortex_a53/bcm_mailbox.h
@@ -232,7 +232,7 @@ public:
         mailbox(MBOX_WC + cpu_base + 4)  = 1 << 31; // ACK From CPU1
         mailbox(MBOX_WC + cpu_base + 8)  = 1 << 31; // ACK From CPU2
         mailbox(MBOX_WC + cpu_base + 12) = 1 << 31; // ACK From CPU3
-        ASM("dsb \t\n isb");
+        //ASM("dsb \t\n isb");
     }
 
     void init(void) {
diff --git a/include/machine/cortex/raspberry_pi3/raspberry_pi3_traits.h b/include/machine/cortex/raspberry_pi3/raspberry_pi3_traits.h
index 8ec2f8e..3496a9a 100644
--- a/include/machine/cortex/raspberry_pi3/raspberry_pi3_traits.h
+++ b/include/machine/cortex/raspberry_pi3/raspberry_pi3_traits.h
@@ -34,7 +34,7 @@ public:
     // Physical Memory at Boot
     static const unsigned int BOOT              = NOT_USED;
     static const unsigned int BOOT_STACK        = 0x0007fffc;   // RAM_BASE + 512KB - 4 (will be used as the stack pointer, not the base)
-    static const unsigned int IMAGE             = 0x00100000;
+    static const unsigned int IMAGE             = 0x00400000;
     static const unsigned int RESET             = SIMULATED ? 0x00010000 : 0x00008000;
     static const unsigned int SETUP             = library_mode ? NOT_USED : RESET;
 
diff --git a/include/real-time.h b/include/real-time.h
index 4f53875..b4485f3 100644
--- a/include/real-time.h
+++ b/include/real-time.h
@@ -26,10 +26,10 @@ class Periodic_Thread: public Thread
 {
 public:
     enum {
-        SAME    = Real_Time_Scheduler_Common::SAME,
-        NOW     = Real_Time_Scheduler_Common::NOW,
-        UNKNOWN = Real_Time_Scheduler_Common::UNKNOWN,
-        ANY     = Real_Time_Scheduler_Common::ANY
+        SAME    = Scheduling_Criterion_Common::SAME,
+        NOW     = Scheduling_Criterion_Common::NOW,
+        UNKNOWN = Scheduling_Criterion_Common::UNKNOWN,
+        ANY     = Scheduling_Criterion_Common::ANY
     };
 
 protected:
@@ -62,7 +62,9 @@ protected:
 
 public:
     struct Configuration: public Thread::Configuration {
-        Configuration(const Microsecond & p, const Microsecond & d = SAME, const Microsecond & cap = UNKNOWN, const Microsecond & act = NOW, const unsigned int n = INFINITE, const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
+        Configuration(const Microsecond & p, const Microsecond & d = SAME, const Microsecond & cap = UNKNOWN, 
+                      const Microsecond & act = NOW, const unsigned int n = INFINITE, const State & s = READY, 
+                      const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
         : Thread::Configuration(s, c, ss), period(p), deadline(d == SAME ? p : d), capacity(cap), activation(act), times(n) {}
 
         Microsecond period;
@@ -109,6 +111,43 @@ protected:
     Alarm _alarm;
 };
 
+class RT_Thread: public Periodic_Thread
+{
+public:
+    RT_Thread(void (* function)(), const Microsecond & deadline, const Microsecond & period = SAME, 
+              const Microsecond & capacity = UNKNOWN, const Microsecond & activation = NOW, 
+              int times = INFINITE, unsigned int stack_size = STACK_SIZE)
+    : Periodic_Thread(Configuration(activation ? activation : period ? period : deadline, deadline,
+                      capacity, activation, activation ? 1 : times, SUSPENDED, 
+                      Criterion(deadline, period ? period : deadline, capacity), stack_size), &entry, 
+                      this, function, activation, times) {
+        if(activation && Criterion::dynamic)
+            // The priority of dynamic criteria will be adjusted to the correct value by the update() in the operator()() of Handler
+            const_cast<Criterion &>(_link.rank())._priority = Criterion::PERIODIC;
+        resume();
+    }
+
+private:
+    static int entry(RT_Thread * t, void (*function)(), const Microsecond activation, int times) {
+        if(activation) {
+            // Wait for activation time
+            t->_semaphore.p();
+
+            // Adjust alarm's period
+            t->_alarm.~Alarm();
+            new (&t->_alarm) Alarm(t->criterion().period(), &t->_handler, times);
+        }
+
+        // Periodic execution loop
+        do {
+            function();
+        } while (wait_next());
+
+        return 0;
+    }
+};
+
+
 typedef Periodic_Thread::Configuration RTConf;
 
 __END_SYS
diff --git a/include/scheduler.h b/include/scheduler.h
index 99bfd36..7c55bfc 100644
--- a/include/scheduler.h
+++ b/include/scheduler.h
@@ -145,6 +145,29 @@ public:
     FCFS(int p = NORMAL, Tn & ... an);
 };
 
+// Rate monotonic
+class RM: public Priority
+{
+public:
+    static const bool time = false;
+    static const bool dynamic = false;
+    static const bool preemptive = true;
+
+public:
+    RM(int p = APERIODIC): Priority(p), _deadline(0), _period(0), _capacity(0) {}
+    RM(const Microsecond & d, const Microsecond & p = SAME, const Microsecond & c = UNKNOWN)
+    : Priority(p ? p : d), _deadline(d), _period(p), _capacity(c) {}
+
+public:
+    const Microsecond period() { return _period; }
+    void period(const Microsecond & p) { _period = p; }
+
+public:
+    Microsecond _deadline;
+    Microsecond _period;
+    Microsecond _capacity;
+};
+
 __END_SYS
 
 #endif
diff --git a/include/utility/heap.h b/include/utility/heap.h
index 3a786c0..d8b6039 100644
--- a/include/utility/heap.h
+++ b/include/utility/heap.h
@@ -7,6 +7,8 @@
 #include <utility/list.h>
 #include <utility/spin.h>
 
+#define DEBUG_E6 0
+
 __BEGIN_UTIL
 
 // Heap
@@ -19,6 +21,9 @@ public:
     using Grouping_List<char>::empty;
     using Grouping_List<char>::size;
     using Grouping_List<char>::grouped_size;
+    using Grouping_List<char>::search_size;
+    using Grouping_List<char>::first_fit;
+    using Grouping_List<char>::print_list;
 
     Heap() {
         db<Init, Heaps>(TRC) << "Heap() => " << this << endl;
@@ -47,6 +52,14 @@ public:
             bytes = sizeof(Element);
 
         Element * e = search_decrementing(bytes);
+        #if DEBUG_E6
+            kout << "####################" << endl;
+            kout << "Current list:" << endl;
+            print_list();
+            kout << "First fit (size):" << first_fit(bytes)->size() << endl;
+            kout << "Best fit (size): " << search_size(bytes)->size() << endl;
+            kout << "####################" << endl;
+        #endif
         if(!e) {
             out_of_memory();
             return 0;
@@ -55,7 +68,7 @@ public:
         int * addr = reinterpret_cast<int *>(e->object() + e->size());
 
         if(typed)
-            *addr++ = reinterpret_cast<int>(this);
+            *addr++ = reinterpret_cast<unsigned long>(this);
         *addr++ = bytes;
 
         db<Heaps>(TRC) << ") => " << reinterpret_cast<void *>(addr) << endl;
diff --git a/include/utility/list.h b/include/utility/list.h
index ccc8954..78d18bc 100644
--- a/include/utility/list.h
+++ b/include/utility/list.h
@@ -1346,7 +1346,7 @@ public:
 
     unsigned int grouped_size() const { return _grouped_size; }
 
-    Element * search_size(unsigned int s) {
+    Element * first_fit(unsigned int s) {
         Element * e = head();
         if(sizeof(Object_Type) < sizeof(Element))
             for(; e && (e->size() < sizeof(Element) / sizeof(Object_Type) + s) && (e->size() != s); e = e->next());
@@ -1355,6 +1355,31 @@ public:
         return e;
     }
 
+    void print_list() {
+      Element* e = head();
+      int i = 1;
+      for (; e; e = e->next())
+        kout << "Element #" << i++ << "->size(): " << e->size() << endl;
+    }
+
+    Element* search_size(unsigned int s)  {
+        Element* e = head();
+        Element* bestFit = nullptr;
+        if (sizeof(Object_Type) < sizeof(Element))
+            for (; e; e = e->next()) {
+                if ((e->size() >= sizeof(Element) / sizeof(Object_Type) + s) || (e->size() == s)) {
+                    if (!bestFit || e->size() < bestFit->size()) bestFit = e;
+                }
+            }
+        else
+            for (; e; e = e->next()) {
+                if (e->size() >= s) {
+                    if (!bestFit || e->size() < bestFit->size()) bestFit = e;
+                }
+            }
+        return bestFit;
+    }
+
     void insert_merging(Element * e, Element ** m1, Element ** m2) {
         db<Lists>(TRC) << "Grouping_List::insert_merging(e=" << e << ")" << endl;
 
diff --git a/makedefs b/makedefs
index 09760e0..5fe17fe 100644
--- a/makedefs
+++ b/makedefs
@@ -94,7 +94,7 @@ UUID                    = $(shell cat /proc/sys/kernel/random/uuid | sed 's/-//g
 # Compiler prefixes
 ia32_COMP_PREFIX	:= /usr/bin/x86_64-linux-gnu-
 armv7_COMP_PREFIX	:= /usr/bin/arm-none-eabi-
-armv8_COMP_PREFIX	:= /usr/bin/arm-none-eabi-
+armv8_COMP_PREFIX	:= /usr/bin/aarch64-linux-gnu-
 rv32_COMP_PREFIX	:= /usr/local/rv32/bin/riscv32-unknown-linux-gnu-
 rv64_COMP_PREFIX	:= /usr/bin/riscv64-linux-gnu-
 COMP_PREFIX		= $($(ARCH)_COMP_PREFIX)
@@ -137,10 +137,10 @@ cortex_IMG_SUFFIX	:= .bin
 endif
 
 ifeq ($(MMOD),raspberry_pi3)
-cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mfloat-abi=hard -mfpu=vfp
+cortex_CC_FLAGS		:= -mcpu=cortex-a53
 cortex_AS_FLAGS		:= -mcpu=cortex-a53
 cortex_LD_FLAGS		:=
-cortex_EMULATOR		= qemu-system-aarch64 -M raspi2 -cpu cortex-a53 -smp 4 -m 1G -serial null -serial mon:stdio -nographic -no-reboot -device loader,file=$(APPLICATION).img,addr=$(IMAGE_ADDR),force-raw=on -kernel 
+cortex_EMULATOR		= qemu-system-aarch64 -M raspi3 -cpu cortex-a53 -smp 4 -m 1G -serial null -serial mon:stdio -nographic -no-reboot -kernel 
 cortex_DEBUGGER		:= gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --nmagic
diff --git a/src/architecture/armv8/armv8_cpu.cc b/src/architecture/armv8/armv8_cpu.cc
new file mode 100644
index 0000000..110d121
--- /dev/null
+++ b/src/architecture/armv8/armv8_cpu.cc
@@ -0,0 +1,139 @@
+// EPOS ARMv8 CPU Mediator Implementation
+
+#include <architecture/armv8/armv8_cpu.h>
+
+__BEGIN_SYS
+
+// Class attributes
+unsigned int CPU::_cpu_clock;
+unsigned int CPU::_bus_clock;
+
+// Class methods
+void CPU::Context::save() volatile
+{
+    ASM("       str     x12, [sp,#-136]          \n"
+        "       adr     x12, .                   \n");
+if(thumb)
+    ASM("       orr     x12, #1                  \n");
+
+    ASM("       str     x12, [%0, #-124]         \n"
+        "       ldr     x12, [sp, #-136]         \n"
+        "       str     lr,  [%0, #-120]         \n"
+        "       str     x12, [%0, #-112]         \n"
+        "       str     x11, [%0, #-104]         \n"
+        "       str     x10, [%0, #-96]         \n"
+        "       str     x9,  [%0, #-88]         \n"
+        "       str     x8,  [%0, #-80]         \n"
+        "       str     x7,  [%0, #-72]         \n"
+        "       str     x6,  [%0, #-64]         \n"
+        "       str     x5,  [%0, #-56]         \n"
+        "       str     x4,  [%0, #-48]         \n"
+        "       str     x3,  [%0, #-40]         \n"
+        "       str     x2,  [%0, #-32]         \n"
+        "       str     x1,  [%0, #-24]         \n"
+        "       str     x0,  [%0, #-16]          \n" : : "r"(this));
+    psr_to_x12();
+    ASM("       str     x12, [%0, #-8]          \n"
+        "       ldr     x12, [sp, #-136]        \n"
+        "       add     %0, %0, #-136           \n"
+        "       ret                             \n" : : "r"(this));
+}
+
+void CPU::Context::load() const volatile
+{
+    ASM("       mov     sp, %0                  \n"
+        "       isb                             \n" : : "r"(this)); // serialize the pipeline so that SP gets updated before the pop
+
+    ASM("       add     sp, sp, #8                  \n");       // skip usp, ulr
+
+    ASM("       ldr     x12, [sp], #8           \n");
+    x12_to_psr();                                           // the context is loaded in SVC; with multitasking, a second context drives a mode change at _int_leave
+    ASM("       ldr     x0, [sp], #8            \n"
+        "       ldr     x1, [sp], #8            \n"
+        "       ldr     x2, [sp], #8            \n"
+        "       ldr     x3, [sp], #8            \n"
+        "       ldr     x4, [sp], #8            \n"
+        "       ldr     x5, [sp], #8            \n"
+        "       ldr     x6, [sp], #8            \n"
+        "       ldr     x7, [sp], #8            \n"
+        "       ldr     x8, [sp], #8            \n"
+        "       ldr     x9, [sp], #8            \n"
+        "       ldr     x10, [sp], #8           \n"
+        "       ldr     x11, [sp], #8           \n"
+        "       ldr     x12, [sp], #8           \n"
+        "       ldr     lr, [sp], #8            \n"
+        "       ldr     x13, [sp], #8           \n"
+        "       br      x13                     \n");
+}
+
+// This function assumes A[T]PCS (i.e. "o" is in x0/a0 and "n" is in x1/a1)
+void CPU::switch_context(Context ** o, Context * n)
+{
+    // Push the context into the stack and adjust "o" to match
+    ASM("       sub     sp, sp, #8                  \n"     // reserve room for PC
+        "       str     lr, [sp, #-8]!          \n"     // push all registers (LR first, x0 last)
+        "       str     x12, [sp, #-8]!         \n" 
+        "       str     x11, [sp, #-8]!         \n"
+        "       str     x10, [sp, #-8]!         \n"
+        "       str     x9, [sp, #-8]!          \n"
+        "       str     x8, [sp, #-8]!          \n"
+        "       str     x7, [sp, #-8]!          \n"
+        "       str     x6, [sp, #-8]!          \n"
+        "       str     x5, [sp, #-8]!          \n"
+        "       str     x4, [sp, #-8]!          \n"
+        "       str     x3, [sp, #-8]!          \n"
+        "       str     x2, [sp, #-8]!          \n"
+        "       str     x1, [sp, #-8]!          \n"
+        "       str     x0, [sp, #-8]!          \n"
+        "       adr     x12, .ret               \n");   // calculate the return address using the saved x12 as a temporary
+if(thumb)
+    ASM("       orr     x12, #1                 \n");   // adjust the return address in thumb mode
+
+    ASM("       str     x12, [sp, #112]          \n");   // save calculated PC
+
+    if(Traits<FPU>::enabled && !Traits<FPU>::user_save)
+        fpu_save();
+
+    psr_to_x12();                                       // save PSR to temporary register x12
+    ASM("       str    x12, [sp, #-8]!                   \n");   // save PSR
+
+    ASM("       sub     sp, sp, #8                  \n");   // skip ulr and usp
+
+    ASM("       add     x1, sp, 0               \n");
+    ASM("       str     x1, [x0]                \n");   // update Context * volatile * o
+
+    // Set the stack pointer to "n" and pop the context
+    ASM("       mov     sp, x1                  \n"     // get Context * volatile n into SP
+        "       isb                             \n");   // serialize the pipeline so SP gets updated before the pop
+
+    ASM("       add     sp, sp, #8              \n");   // skip usp and ulr
+
+    ASM("       ldr     x12, [sp], #8            \n");   // pop PSR into temporary register x12
+    x12_to_psr();                                       // restore PSR
+
+    if(Traits<FPU>::enabled && !Traits<FPU>::user_save)
+        fpu_restore();
+
+    ASM("       ldr     x0, [sp], #8            \n"
+        "       ldr     x1, [sp], #8            \n"
+        "       ldr     x2, [sp], #8            \n"
+        "       ldr     x3, [sp], #8            \n"
+        "       ldr     x4, [sp], #8            \n"
+        "       ldr     x5, [sp], #8            \n"
+        "       ldr     x6, [sp], #8            \n"
+        "       ldr     x7, [sp], #8            \n"
+        "       ldr     x8, [sp], #8            \n"
+        "       ldr     x9, [sp], #8            \n"
+        "       ldr     x10, [sp], #8           \n"
+        "       ldr     x11, [sp], #8           \n"
+        "       ldr     x12, [sp], #8           \n"
+        "       ldr     lr, [sp], #8            \n");   // pop all registers (x0 first, LR last)
+
+#ifdef __cortex_m__
+    int_enable();
+#endif
+
+    ASM(".ret:  ret                             \n");   // return
+}
+
+__END_SYS
diff --git a/src/architecture/armv8/armv8_cpu_init.cc b/src/architecture/armv8/armv8_cpu_init.cc
new file mode 100644
index 0000000..0f127df
--- /dev/null
+++ b/src/architecture/armv8/armv8_cpu_init.cc
@@ -0,0 +1,31 @@
+// EPOS ARMv8 CPU Mediator Initialization
+
+#include <architecture.h>
+
+extern "C" { void __epos_library_app_entry(void); }
+
+__BEGIN_SYS
+
+void CPU::init()
+{
+    db<Init, CPU>(TRC) << "CPU::init()" << endl;
+
+    if(CPU::id() == 0) {
+        if(Traits<MMU>::enabled)
+            MMU::init();
+        else
+            db<Init, MMU>(WRN) << "MMU is disabled!" << endl;
+    }
+
+#ifdef __PMU_H
+    if(Traits<PMU>::enabled)
+        PMU::init();
+#endif
+
+#ifdef __TSC_H
+    if(Traits<TSC>::enabled)
+        TSC::init();
+#endif
+}
+
+__END_SYS
diff --git a/src/architecture/armv8/armv8_cpu_test.cc b/src/architecture/armv8/armv8_cpu_test.cc
new file mode 100644
index 0000000..dd345a0
--- /dev/null
+++ b/src/architecture/armv8/armv8_cpu_test.cc
@@ -0,0 +1,63 @@
+// EPOS ARMv8 Test Program
+
+#include <architecture/cpu.h>
+
+using namespace EPOS;
+
+int main()
+{
+    OStream cout;
+    cout << "ARMv8 test" << endl;
+
+    CPU cpu;
+
+    {
+        volatile bool lock = false;
+        if(cpu.tsl(lock))
+            cout << "tsl(): doesn't function properly!(1)" << endl;
+        else
+            if(cpu.tsl(lock))
+                cout << "tsl(): ok" << endl;
+            else
+                cout << "tsl(): doesn't function properly!(2)" << endl;
+    }
+    {
+        volatile int number = 100;
+        volatile int tmp;
+        if((tmp = cpu.finc(number)) != 100)
+            cout << "finc(): doesn't function properly (n=" << tmp << ", should be 100)!" << endl;
+        else
+            if((tmp = cpu.finc(number)) != 101)
+                cout << "finc(): doesn't function properly (n=" << tmp << ", should be 101)!" << endl;
+            else
+                cout << "finc(): ok" << endl;
+    }
+    {
+        volatile int number = 100;
+        volatile int tmp;
+        if((tmp = cpu.fdec(number)) != 100)
+            cout << "fdec(): doesn't function properly (n=" << tmp << ", should be 100)!" << endl;
+        else
+            if((tmp = cpu.fdec(number)) != 99)
+                cout << "fdec(): doesn't function properly (n=" << tmp << ", should be 99)!" << endl;
+            else
+                cout << "fdec(): ok" << endl;
+    }
+    {
+        volatile int number = 100;
+        volatile int compare = number;
+        volatile int replacement = number - 1;
+        volatile int tmp;
+        if((tmp = cpu.cas(number, compare, replacement)) != compare)
+            cout << "cas(): doesn't function properly [1] (n=" << tmp << ", should be " << compare << ")!" << endl;
+        else
+            if((tmp = cpu.cas(number, compare, replacement)) != replacement)
+                cout << "cas(): doesn't function properly [2] (n=" << tmp << ", should be " << replacement << ")!" << endl;
+            else
+                cout << "cas(): ok" << endl;
+    }
+
+    cout << "ARMv8 test finished" << endl;
+
+    return 0;
+}
diff --git a/src/architecture/armv8/armv8_crt0.S b/src/architecture/armv8/armv8_crt0.S
new file mode 100644
index 0000000..170e504
--- /dev/null
+++ b/src/architecture/armv8/armv8_crt0.S
@@ -0,0 +1,34 @@
+// EPOS ARMv8 Program Starter
+
+        .file "armv8_crt0.S"
+
+        .align  2
+        .global _start
+        .type   _start, function
+_start:
+
+#ifdef __cortex_m__
+        // Allocate a temporary stack for INIT, since we don't have a proper SETUP for Cortex-M
+        ldr     x0, =__boot_stack__
+        mov     sp, x0
+
+        // Clear the BSS
+        bl      _clear_bss
+#endif
+
+#ifdef __cortex_a__
+        // Temporary stack(s) for INIT were created and configure by SETUP
+        // BSS was cleared by SETUP
+#endif
+
+        bl      _init
+
+        .align  2
+        .globl  __epos_app_entry
+        .type   __epos_app_entry, function
+__epos_app_entry:
+        // Main's stack was allocated by Thread::init()
+        bl      main
+        str     x0, [sp, #-8]!        // save main's return value to be used by exit()
+        bl      _fini
+        bl      _exit
diff --git a/src/architecture/armv8/armv8_mmu.cc b/src/architecture/armv8/armv8_mmu.cc
new file mode 100644
index 0000000..675302e
--- /dev/null
+++ b/src/architecture/armv8/armv8_mmu.cc
@@ -0,0 +1,10 @@
+// EPOS ARMv8 MMU Mediator Implementation
+
+#include <architecture/armv8/armv8_mmu.h>
+
+__BEGIN_SYS
+
+ARMv8_MMU::List ARMv8_MMU::_free[colorful * COLORS + 1];
+ARMv8_MMU::Page_Directory * ARMv8_MMU::_master;
+
+__END_SYS
diff --git a/src/architecture/armv8/armv8_mmu_init.cc b/src/architecture/armv8/armv8_mmu_init.cc
new file mode 100644
index 0000000..cf3ef16
--- /dev/null
+++ b/src/architecture/armv8/armv8_mmu_init.cc
@@ -0,0 +1,20 @@
+// EPOS ARMv8 MMU Mediator Initialization
+
+#include <architecture/mmu.h>
+#include <system.h>
+
+__BEGIN_SYS
+
+void ARMv8_MMU::init()
+{
+    db<Init, MMU>(TRC) << "MMU::init()" << endl;
+    db<Init, MMU>(INF) << "MMU::init()" << System::info() << hex << ", base=" << System::info()->pmm.free1_base << ", top=" << System::info()->pmm.free1_top << endl;
+    free(System::info()->pmm.free1_base, pages(System::info()->pmm.free1_top - System::info()->pmm.free1_base));
+   
+    // Remember the master page directory (created during SETUP)
+    _master = current();
+    db<Init, MMU>(INF) << "MMU::master page directory=" << _master << endl;
+}
+
+__END_SYS
+
diff --git a/src/architecture/armv8/armv8_pmu.cc b/src/architecture/armv8/armv8_pmu.cc
new file mode 100644
index 0000000..8d75040
--- /dev/null
+++ b/src/architecture/armv8/armv8_pmu.cc
@@ -0,0 +1,109 @@
+// EPOS ARMv8 PMU Events Declaration
+
+#include <architecture/pmu.h>
+
+#if defined(__mmod_zynq__) | defined(__mmod_raspberry_pi3__) | defined(__mmod_realview_pbx__)
+
+__BEGIN_SYS
+
+const ARMv8_A_PMU::Event ARMv8_A_PMU::_events[ARMv8_A_PMU::EVENTS] = {
+    ARMv8_A_PMU::INSTRUCTIONS_ARCHITECTURALLY_EXECUTED,  // 0
+    ARMv8_A_PMU::IMMEDIATE_BRANCH,                       // 1
+    ARMv8_A_PMU::CYCLE,                                  // 2
+    ARMv8_A_PMU::BRANCHES_ARCHITECTURALLY_EXECUTED,      // 3
+    ARMv8_A_PMU::MISPREDICTED_BRANCH,                    // 4
+    ARMv8_A_PMU::L1D_ACCESS,                             // 5
+    ARMv8_A_PMU::L2D_ACCESS,                             // 6
+    ARMv8_A_PMU::L1D_REFILL,                             // 7
+    ARMv8_A_PMU::DATA_MEMORY_ACCESS,                     // 8 (LLC MISS)
+    ARMv8_A_PMU::L1I_REFILL,                             // 9
+    ARMv8_A_PMU::L1I_TLB_REFILL,                         // 10
+    ARMv8_A_PMU::PREDICTABLE_BRANCH_EXECUTED,            // 11
+    ARMv8_A_PMU::L1D_WRITEBACK,                          // 12
+    ARMv8_A_PMU::L2D_WRITEBACK,                          // 13
+    ARMv8_A_PMU::L2D_REFILL,                             // 14
+    ARMv8_A_PMU::UNALIGNED_LOAD_STORE,                   // 15
+    ARMv8_A_PMU::L1I_ACCESS,                             // 16
+    ARMv8_A_PMU::L1D_TLB_REFILL,                         // 17
+    ARMv8_A_PMU::EXCEPTION_TAKEN,                        // 18
+    ARMv8_A_PMU::BUS_ACCESS,                             // 19
+    ARMv8_A_PMU::LOCAL_MEMORY_ERROR,                     // 20
+    ARMv8_A_PMU::INSTRUCTION_SPECULATIVELY_EXECUTED,     // 21
+    ARMv8_A_PMU::BUS_CYCLE,                              // 22
+    ARMv8_A_PMU::CHAIN,                                  // 23
+    ARMv8_A_PMU::// Cortex-A9 specific events
+    ARMv8_A_PMU::JAVA_BYTECODE_EXECUTE,                  // 24
+    ARMv8_A_PMU::SOFTWARE_JAVA_BYTECODE_EXECUTED,        // 25
+    ARMv8_A_PMU::JAZELLE_BACKWARDS_BRANCHES_EXECUTED,    // 26
+    ARMv8_A_PMU::COHERENT_LINEFILL_MISS,                 // 27
+    ARMv8_A_PMU::COHERENT_LINEFILL_HIT,                  // 28
+    ARMv8_A_PMU::ICACHE_DEPENDENT_STALL_CYCLES,          // 29
+    ARMv8_A_PMU::DCACHE_DEPENDENT_STALL_CYCLES,          // 30
+    ARMv8_A_PMU::MAIN_TLB_MISS_STALL_CYCLES,             // 31
+    ARMv8_A_PMU::STREX_PASSED,                           // 32
+    ARMv8_A_PMU::STREX_FAILED,                           // 33
+    ARMv8_A_PMU::DATA_EVICTION,                          // 34
+    ARMv8_A_PMU::ISSUE_DOESNT_DISPATCH,                  // 35
+    ARMv8_A_PMU::ISSUE_EMPTY,                            // 36
+    ARMv8_A_PMU::ISSUE_CORE_RENAMING,                    // 37
+    ARMv8_A_PMU::PREDICTABLE_FUNCTION_RETURNS,           // 38
+    ARMv8_A_PMU::MAIN_EXECUTION_UNIT_RETURNS,            // 39
+    ARMv8_A_PMU::SECOND_EXECUTION_UNIT_RETURNS,          // 40
+    ARMv8_A_PMU::LOAD_STORE_INSTRUCTIONS,                // 41
+    ARMv8_A_PMU::FLOATING_POINT_INSTRUCTIONS,            // 42
+    ARMv8_A_PMU::NEON_INSTRUCTIONS,                      // 43
+    ARMv8_A_PMU::PROCESSOR_STALL_PLD,                    // 44
+    ARMv8_A_PMU::PROCESSOR_STALL_WRITE_MEMORY,           // 45
+    ARMv8_A_PMU::PROCESSOR_STALL_ITLB_MISS,              // 46
+    ARMv8_A_PMU::PROCESSOR_STALL_DTLB_MISS,              // 47
+    ARMv8_A_PMU::PROCESSOR_STALL_IUTLB_MISS,             // 48
+    ARMv8_A_PMU::PROCESSOR_STALL_DUTLB_MISS,             // 49
+    ARMv8_A_PMU::PROCESSOR_STALL_DMB,                    // 50
+    ARMv8_A_PMU::INTEGER_CLOCK_ENABLED,                  // 51
+    ARMv8_A_PMU::DATA_ENGINE_CLOCK_ENABLED,              // 52
+    ARMv8_A_PMU::ISB_INSTRUCTIONS,                       // 53
+    ARMv8_A_PMU::DSB_INSTRUCTIONS,                       // 54
+    ARMv8_A_PMU::DMB_INSTRUCTIONS,                       // 55
+    ARMv8_A_PMU::EXTERNAL_INTERRUPTS,                    // 56
+    ARMv8_A_PMU::PLE_CACHE_LINE_REQUEST_COMPLETED,       // 57
+    ARMv8_A_PMU::PLE_CACHE_LINE_REQUEST_SKIPPED,         // 58
+    ARMv8_A_PMU::PLE_FIFO_FLUSH,                         // 59
+    ARMv8_A_PMU::PLE_REQUEST_COMPLETED,                  // 60
+    ARMv8_A_PMU::PLE_FIFO_OVERFLOW,                      // 61
+    ARMv8_A_PMU::PLE_REQUEST_PROGRAMMED,                 // 62
+    ARMv8_A_PMU::// ARM Cortex-A53 specific events
+    ARMv8_A_PMU::BUS_ACCESS_LD,                          // 63
+    ARMv8_A_PMU::BUS_ACCESS_ST,                          // 64
+    ARMv8_A_PMU::BR_INDIRECT_SPEC,                       // 65
+    ARMv8_A_PMU::EXC_IRQ,                                // 66
+    ARMv8_A_PMU::EXC_FIQ,                                // 67
+    ARMv8_A_PMU::EXTERNAL_MEM_REQUEST,                   // 68
+    ARMv8_A_PMU::EXTERNAL_MEM_REQUEST_NON_CACHEABLE,     // 69
+    ARMv8_A_PMU::PREFETCH_LINEFILL,                      // 70
+    ARMv8_A_PMU::ICACHE_THROTTLE,                        // 71
+    ARMv8_A_PMU::ENTER_READ_ALLOC_MODE,                  // 72
+    ARMv8_A_PMU::READ_ALLOC_MODE,                        // 73
+    ARMv8_A_PMU::PRE_DECODE_ERROR,                       // 74
+    ARMv8_A_PMU::DATA_WRITE_STALL_ST_BUFFER_FULL,        // 75
+    ARMv8_A_PMU::SCU_SNOOPED_DATA_FROM_OTHER_CPU,        // 76
+    ARMv8_A_PMU::CONDITIONAL_BRANCH_EXECUTED,            // 77
+    ARMv8_A_PMU::IND_BR_MISP,                            // 78
+    ARMv8_A_PMU::IND_BR_MISP_ADDRESS_MISCOMPARE,         // 79
+    ARMv8_A_PMU::CONDITIONAL_BRANCH_MISP,                // 80
+    ARMv8_A_PMU::L1_ICACHE_MEM_ERROR,                    // 81
+    ARMv8_A_PMU::L1_DCACHE_MEM_ERROR,                    // 82
+    ARMv8_A_PMU::TLB_MEM_ERROR,                          // 83
+    ARMv8_A_PMU::EMPTY_DPU_IQ_NOT_GUILTY,                // 84
+    ARMv8_A_PMU::EMPTY_DPU_IQ_ICACHE_MISS,               // 85
+    ARMv8_A_PMU::EMPTY_DPU_IQ_IMICRO_TLB_MISS,           // 86
+    ARMv8_A_PMU::EMPTY_DPU_IQ_PRE_DECODE_ERROR,          // 87
+    ARMv8_A_PMU::INTERLOCK_CYCLE_NOT_GUILTY,             // 88
+    ARMv8_A_PMU::INTERLOCK_CYCLE_LD_ST_WAIT_AGU_ADDRESS, // 89
+    ARMv8_A_PMU::INTERLOCK_CYCLE_ADV_SIMD_FP_INST,       // 90
+    ARMv8_A_PMU::INTERLOCK_CYCLE_WR_STAGE_STALL_BC_MISS, // 91
+    ARMv8_A_PMU::INTERLOCK_CYCLE_WR_STAGE_STALL_BC_STR   // 92
+};
+
+__END_SYS
+
+#endif
\ No newline at end of file
diff --git a/src/architecture/armv8/armv8_pmu_init.cc b/src/architecture/armv8/armv8_pmu_init.cc
new file mode 100644
index 0000000..f3b6341
--- /dev/null
+++ b/src/architecture/armv8/armv8_pmu_init.cc
@@ -0,0 +1,26 @@
+// EPOS ARMv8 PMU Mediator Initialization
+
+#include <architecture/pmu.h>
+
+#if defined(__mmod_zynq__) | defined(__mmod_raspberry_pi3__) | defined(__mmod_realview_pbx__)
+
+__BEGIN_SYS
+
+void ARMv8_A_PMU::init()
+{
+    db<Init, PMU>(TRC) << "PMU::init()" << endl;
+
+    // Set global enable, reset all counters including cycle counter, and
+    // export the events
+    pmcr(pmcr() | PMCR_E | PMCR_P | PMCR_C | PMCR_X);
+
+    // Clear all overflows:
+    pmovsr(~0);
+
+    // Enable cycle counter
+    pmcntenset(pmcntenset() | PMCNTENSET_C);
+}
+
+__END_SYS
+
+#endif
diff --git a/src/architecture/armv8/armv8_tsc.cc b/src/architecture/armv8/armv8_tsc.cc
new file mode 100644
index 0000000..ec8028a
--- /dev/null
+++ b/src/architecture/armv8/armv8_tsc.cc
@@ -0,0 +1,13 @@
+// EPOS ARMv8 Time-Stamp Counter Mediator Implementation
+
+#include <architecture/tsc.h>
+
+__BEGIN_SYS
+
+#if defined(__mmod_emote3__) || defined(__mmod_lm3s811__)
+
+volatile TSC::Time_Stamp TSC::_overflow = 0;
+
+#endif
+
+__END_SYS
diff --git a/src/architecture/armv8/armv8_tsc_init.cc b/src/architecture/armv8/armv8_tsc_init.cc
new file mode 100644
index 0000000..74b63f9
--- /dev/null
+++ b/src/architecture/armv8/armv8_tsc_init.cc
@@ -0,0 +1,53 @@
+// EPOS ARMv8 Time-Stamp Counter Mediator Initialization
+
+
+#include <architecture/tsc.h>
+#include <machine/timer.h>
+
+#if defined(__cortex_a__)
+
+__BEGIN_SYS
+
+void TSC::init()
+{
+    db<Init, TSC>(TRC) << "TSC::init()" << endl;
+
+
+    if(CPU::id() == 0) {
+        // Disable counting before programming
+        reg(GTCLR) = 0;
+
+        // Set timer to 0
+        reg(GTCTRL) = 0;
+        reg(GTCTRH) = 0;
+
+        // Re-enable counting
+        reg(GTCLR) = 1;
+    }
+}
+
+__END_SYS
+
+#elif defined(__cortex_m__)
+
+#include __HEADER_MMOD(sysctrl)
+#include __HEADER_MMOD(memory_map)
+
+__BEGIN_SYS
+
+void TSC::init()
+{
+    db<Init, TSC>(TRC) << "TSC::init()" << endl;
+
+    SysCtrl * scr = reinterpret_cast<SysCtrl *>(Memory_Map::SCR_BASE);
+    GPTM * gptm = reinterpret_cast<GPTM *>(Memory_Map::TIMER0_BASE + 0x1000 * (Traits<Timer>::UNITS - 1));
+
+    scr->clock_timer(Traits<Timer>::UNITS - 1);
+    gptm->config(0xffffffff, true, (Traits<Build>::MODEL == Traits<Build>::LM3S811) ? false : true);
+
+    // time-out interrupt will be registered later at IC::init(), because IC hasn't been initialized yet
+}
+
+__END_SYS
+
+#endif
diff --git a/src/architecture/armv8/makefile b/src/architecture/armv8/makefile
new file mode 100644
index 0000000..0a2eaff
--- /dev/null
+++ b/src/architecture/armv8/makefile
@@ -0,0 +1,33 @@
+# EPOS ARMv7 Architecture Makefile
+
+include ../../../makedefs
+
+OBJS := $(subst .cc,.o,$(shell find *.cc | grep -v _init | grep -v _test))
+CRTS := $(subst .S,.o,$(shell find *.S | grep crt)) $(ARCH)_crtbegin.o $(ARCH)_crtend.o 
+CRTSI := $(subst .S,.s,$(shell find *.S | grep crt))
+INITS := $(subst .cc,.o,$(shell find *.cc | grep _init))
+
+all:		crts $(LIBARCH) $(LIBINIT)
+
+crts:		$(CRTS)
+		$(INSTALL) $(ARCH)_crt0.o $(LIB)/crt0_$(MMOD).o
+		$(INSTALL) $(ARCH)_crtbegin.o $(LIB)/crtbegin_$(MMOD).o
+		$(INSTALL) $(ARCH)_crtend.o $(LIB)/crtend_$(MMOD).o
+
+.INTERMEDIATE:	$(CRTSI)
+
+$(LIBARCH):	$(LIBARCH)($(OBJS))
+
+$(LIBINIT):	$(LIBINIT)($(INITS))
+
+cpu.o		: cpu.cc
+		$(CXX) $(CXXFLAGS) -fomit-frame-pointer $<
+
+$(ARCH)_crtbegin.o: ../common/crtbegin.c
+		$(CC) $(CCFLAGS) $< -o $@
+
+$(ARCH)_crtend.o: ../common/crtend.c
+		$(CC) $(CCFLAGS) $< -o $@
+
+clean:
+		$(CLEAN) *.o *.s *_test
diff --git a/src/architecture/common/mmu_common_init.cc b/src/architecture/common/mmu_common_init.cc
index e084dc2..448eae2 100644
--- a/src/architecture/common/mmu_common_init.cc
+++ b/src/architecture/common/mmu_common_init.cc
@@ -19,7 +19,7 @@ void No_MMU::init()
     // Allocations (using Grouping_List<Frame>::search_decrementing() start from the end
     // To preserve the BOOT stacks until the end of INIT, the free memory list initialization is split in two sections
     // with allocations (from the end) of the first section taking place first
-    free(&_end, pages(Memory_Map::RAM_TOP + 1 - Traits<Machine>::STACK_SIZE * Traits<Machine>::CPUS - reinterpret_cast<unsigned int>(&_end)));
+    free(&_end, pages(Memory_Map::RAM_TOP + 1 - Traits<Machine>::STACK_SIZE * Traits<Machine>::CPUS - reinterpret_cast<unsigned long>(&_end)));
     free(Memory_Map::RAM_TOP + 1 - Traits<Machine>::STACK_SIZE * Traits<Machine>::CPUS, pages(Traits<Machine>::STACK_SIZE * Traits<Machine>::CPUS));
 }
 
diff --git a/src/machine/cortex/raspberry_pi3/raspberry_pi3_ic.cc b/src/machine/cortex/raspberry_pi3/raspberry_pi3_ic.cc
index e64c30d..bd47394 100644
--- a/src/machine/cortex/raspberry_pi3/raspberry_pi3_ic.cc
+++ b/src/machine/cortex/raspberry_pi3/raspberry_pi3_ic.cc
@@ -5,7 +5,7 @@
 #include <machine/timer.h>
 #include <process.h>
 
-extern "C" { void _int_entry() __attribute__ ((naked, nothrow, alias("_ZN4EPOS1S2IC5entryEv"))); }
+extern "C" { void _int_entry() __attribute__ ((nothrow, alias("_ZN4EPOS1S2IC5entryEv"))); }
 extern "C" { void _dispatch(unsigned int) __attribute__ ((alias("_ZN4EPOS1S2IC8dispatchEj"))); }
 extern "C" { void _eoi(unsigned int) __attribute__ ((alias("_ZN4EPOS1S2IC3eoiEj"))); }
 extern "C" { void _undefined_instruction() __attribute__ ((alias("_ZN4EPOS1S2IC21undefined_instructionEv"))); }
@@ -144,24 +144,24 @@ IC::Interrupt_Handler IC::_eoi_vector[INTS] = {
 // Class methods
 void IC::entry()
 {
-    // We assume A[T]PCS ARM ABI, so any function using registers r4 until r11 will save those upon beginning and restore them when exiting. 
-    // An interrupt can happen in the middle of one such function, but if the ISR drives the PC through other functions that use the same registers, they will save and restore them. We therefore don't need to save r4-r11 here.
-    ASM("       .equ    MODE_IRQ, 0x12                                  \n"
+    // We assume A[T]PCS ARM ABI, so any function using registers x4 until x11 will save those upon beginning and restore them when exiting. 
+    // An interrupt can happen in the middle of one such function, but if the ISR drives the PC through other functions that use the same registers, they will save and restore them. We therefore don't need to save x4-x11 here.
+    /*ASM("       .equ    MODE_IRQ, 0x12                                  \n"
         "       .equ    MODE_SVC, 0x13                                  \n"
         "       .equ    IRQ_BIT,  0x80                                  \n"
         "       .equ    FIQ_BIT,  0x40                                  \n"
         "       msr     cpsr_c, #MODE_SVC | IRQ_BIT | FIQ_BIT           \n"     // go to SVC mode
-        "       stmfd   sp!, {r0-r3, r12, lr, pc}                       \n"     // save current context (lr, sp and spsr are banked registers)
+        "       stmfd   sp!, {x0-x3, x12, lr, pc}                       \n"     // save current context (lr, sp and spsr are banked registers)
         "       msr     cpsr_c, #MODE_IRQ | IRQ_BIT | FIQ_BIT           \n"     // go to IRQ mode to recover LR
-        "       sub     r0, lr, #4                                      \n"     // r0 = return address as entering IRQ more
-        "       mrs     r1, spsr                                        \n"     // r1 = IRQ_spsr (to be visible at SVC)
+        "       sub     x0, lr, #4                                      \n"     // x0 = return address as entering IRQ more
+        "       mrs     x1, spsr                                        \n"     // x1 = IRQ_spsr (to be visible at SVC)
         "       msr     cpsr_c, #MODE_SVC | IRQ_BIT | FIQ_BIT           \n"     // go back to SVC mode
-        "       str     r0, [sp, #24]                                   \n"     // overwrite saved PC with r0 (saved return address)
-        "       push    {r1}                                            \n"     // push IRQ_spsr
+        "       str     x0, [sp, #24]                                   \n"     // overwrite saved PC with x0 (saved return address)
+        "       str     x1, [sp, #8]!                                   \n"     // push IRQ_spsr
         "       bl      _dispatch                                       \n"
-        "       pop     {r1}                                            \n"     // pop IRQ_spsr into SVC_spsr
-        "       msr     spsr_cfxs, r1                                   \n"
-        "       ldmfd   sp!, {r0-r3, r12, lr, pc}^                      \n");   // restore the context (including PC in ldmfd cause a mode change to the mode before the interrupt)
+        "       ldr     x1, [sp], #8                                    \n"     // pop IRQ_spsr into SVC_spsr
+        "       msr     spsr_cfxs, x1                                   \n"
+        "       ldmfd   sp!, {x0-x3, x12, lr, pc}^                      \n");   // restore the context (including PC in ldmfd cause a mode change to the mode before the interrupt)*/
 }
 
 void IC::dispatch(unsigned int i)
diff --git a/src/setup/setup_raspberry_pi3.cc b/src/setup/setup_raspberry_pi3.cc
index f0f641b..6306c8f 100644
--- a/src/setup/setup_raspberry_pi3.cc
+++ b/src/setup/setup_raspberry_pi3.cc
@@ -10,8 +10,8 @@ extern "C" {
     void _bss_clear();
 
     // SETUP entry point is the Vector Table and resides in the .init section (not in .text), so it will be linked first and will be the first function after the ELF header in the image.
-    void _entry() __attribute__ ((used, naked, section(".init")));
-    void _reset() __attribute__ ((naked)); // so it can be safely reached from the vector table
+    void _entry() __attribute__ ((used, section(".init")));
+    void _reset(); // so it can be safely reached from the vector table
     void _setup(); // just to create a Setup object
 
     // LD eliminates this variable while performing garbage collection, so --undefined=__boot_time_system_info must be present while linking
@@ -64,7 +64,7 @@ private:
     typedef System_Info::Load_Map LM;
 
 private:
-    // TTBR0 Page Table Entry Descriptor for Sections configuration --> One level translation for Flat Mapping
+    // TTBx0 Page Table Entry Descriptor for Sections configuration --> One level translation for Flat Mapping
     enum {
         TTB_MEMORY_DESCRIPTOR           = 0x90c0e,
         TTB_DEVICE_DESCRIPTOR           = 0x90c0a,
@@ -460,13 +460,13 @@ void Setup::say_hi()
     if(!si->lm.has_sys)
         db<Setup>(INF) << "No SYSTEM in boot image, assuming EPOS is a library!" << endl;
 
-    kout << "Setting up this machine as follows: " << endl;
+    /*kout << "Setting up this machine as follows: " << endl;
     kout << "  Mode:         " << ((Traits<Build>::MODE == Traits<Build>::LIBRARY) ? "library" : (Traits<Build>::MODE == Traits<Build>::BUILTIN) ? "built-in" : "kernel") << endl;
     kout << "  Processor:    " << Traits<Machine>::CPUS << " x Cortex A53 at " << Traits<CPU>::CLOCK / 1000000 << " MHz (BUS clock = " << Traits<CPU>::CLOCK / 1000000 << " MHz)" << endl;
     kout << "  Memory:       " << (si->bm.mem_top - si->bm.mem_base) / 1024 << " KB [" << (void *)si->bm.mem_base << ":" << (void *)si->bm.mem_top << "]" << endl;
     kout << "  User memory:  " << (si->pmm.usr_mem_top - si->pmm.usr_mem_base) / 1024 << " KB [" << (void *)si->pmm.usr_mem_base << ":" << (void *)si->pmm.usr_mem_top << "]" << endl;
     kout << "  I/O space:    " << (si->bm.mio_top - si->bm.mio_base) / 1024 << " KB [" << (void *)si->bm.mio_base << ":" << (void *)si->bm.mio_top << "]" << endl;
-    kout << "  Node Id:      ";
+    kout << "  Node Id:      ";*/
     if(si->bm.node_id != -1)
         kout << si->bm.node_id << " (" << Traits<Build>::NODES << ")" << endl;
     else
@@ -505,14 +505,14 @@ void Setup::setup_pt(PT_Entry * pts, Phy_Addr base, unsigned int size, unsigned
 
 void Setup::setup_sys_pt()
 {
-    db<Setup>(TRC) << "Setup::setup_sys_pt(pmm="
+    /*db<Setup>(TRC) << "Setup::setup_sys_pt(pmm="
                    << "{si="      << (void *)si->pmm.sys_info
                    << ",pt="      << (void *)si->pmm.sys_pt
                    << ",pd="      << (void *)si->pmm.sys_pd
                    << ",sysc={b=" << (void *)si->pmm.sys_code << ",s=" << MMU::pages(si->lm.sys_code_size) << "}"
                    << ",sysd={b=" << (void *)si->pmm.sys_data << ",s=" << MMU::pages(si->lm.sys_data_size) << "}"
                    << ",syss={b=" << (void *)si->pmm.sys_stack << ",s=" << MMU::pages(si->lm.sys_stack_size) << "}"
-                   << "})" << endl;
+                   << "})" << endl;*/
 
     // Get the physical address for the SYSTEM Page Table
     PT_Entry * sys_pt = reinterpret_cast<PT_Entry *>(si->pmm.sys_pt);
@@ -551,10 +551,10 @@ void Setup::setup_sys_pt()
 
 void Setup::setup_app_pt()
 {
-    db<Setup>(TRC) << "Setup::setup_app_pt(appc={b=" << (void *)si->pmm.app_code << ",s=" << MMU::pages(si->lm.app_code_size) << "}"
+    /*db<Setup>(TRC) << "Setup::setup_app_pt(appc={b=" << (void *)si->pmm.app_code << ",s=" << MMU::pages(si->lm.app_code_size) << "}"
                    << ",appd={b=" << (void *)si->pmm.app_data << ",s=" << MMU::pages(si->lm.app_data_size) << "}"
                    << ",appe={b=" << (void *)si->pmm.app_extra << ",s=" << MMU::pages(si->lm.app_extra_size) << "}"
-                   << "})" << endl;
+                   << "})" << endl;*/
 
     // Get the physical address for the first APPLICATION Page Tables
     PT_Entry * app_code_pt = reinterpret_cast<PT_Entry *>(si->pmm.app_code_pts);
@@ -576,7 +576,7 @@ void Setup::setup_app_pt()
 
 void Setup::setup_sys_pd()
 {
-    db<Setup>(TRC) << "setup_sys_pd(bm="
+    /*db<Setup>(TRC) << "setup_sys_pd(bm="
                    << "{memb="  << (void *)si->bm.mem_base
                    << ",memt="  << (void *)si->bm.mem_top
                    << ",miob="  << (void *)si->bm.mio_base
@@ -593,11 +593,11 @@ void Setup::setup_sys_pd()
                    << ",syss="  << (void *)si->pmm.sys_stack
                    << ",apct="  << (void *)si->pmm.app_code_pts
                    << ",apdt="  << (void *)si->pmm.app_data_pts
-                   << ",fr1b="  << (void *)si->pmm.free1_base
-                   << ",fr1t="  << (void *)si->pmm.free1_top
-                   << ",fr2b="  << (void *)si->pmm.free2_base
-                   << ",fr2t="  << (void *)si->pmm.free2_top
-                   << "})" << endl;
+                   << ",fx1b="  << (void *)si->pmm.free1_base
+                   << ",fx1t="  << (void *)si->pmm.free1_top
+                   << ",fx2b="  << (void *)si->pmm.free2_base
+                   << ",fx2t="  << (void *)si->pmm.free2_top
+                   << "})" << endl;*/
 
     // Get the physical address for the System Page Directory
     PT_Entry * sys_pd = reinterpret_cast<PT_Entry *>(si->pmm.sys_pd);
@@ -608,7 +608,7 @@ void Setup::setup_sys_pd()
     // Calculate the number of page tables needed to map the physical memory
     unsigned int mem_size = MMU::pages(si->bm.mem_top - si->bm.mem_base);
     unsigned int n_pts = MMU::page_tables(mem_size);
-    db<Setup>(INF) << "mem_size="<< mem_size << ",n_pts=" << n_pts << (void *) si->pmm.phy_mem_pts << ",syspd=" << (void *) si->pmm.sys_pd << "Size pte=" << sizeof(PT_Entry) << endl;
+    //db<Setup>(INF) << "mem_size="<< mem_size << ",n_pts=" << n_pts << (void *) si->pmm.phy_mem_pts << ",syspd=" << (void *) si->pmm.sys_pd << "Size pte=" << sizeof(PT_Entry) << endl;
     // Map the whole physical memory into the page tables pointed by phy_mem_pts
     PT_Entry * pts = reinterpret_cast<PT_Entry *>(si->pmm.phy_mem_pts);
 
@@ -616,7 +616,7 @@ void Setup::setup_sys_pd()
 
     setup_pt(pts, si->bm.mem_base, mem_size, n_pts, Flags::SYS);
 
-    db<Setup>(INF) << "PHY_MEM_PT("<< (void *) pts <<")=" << *reinterpret_cast<Page_Table *>(pts) << endl; // if this print is removed, the config goes wrong
+    //db<Setup>(INF) << "PHY_MEM_PT("<< (void *) pts <<")=" << *reinterpret_cast<Page_Table *>(pts) << endl; // if this print is removed, the config goes wrong
     db<Setup>(INF) << "mem_size="<< mem_size <<",n_pts=" << n_pts << endl;
 
     db<Setup>(INF) << "pts done" << endl;
@@ -656,10 +656,10 @@ void Setup::setup_sys_pd()
         sys_pd[i] = MMU::phy2pde((si->pmm.io_pts + j * sizeof(Page_Table)));
     db<Setup>(INF) << "sys pd for io pts done" << endl;
 
-    db<Setup>(INF) << "attach SYS pt on sys pd[sys]:" << MMU::directory(SYS) 
+   /* db<Setup>(INF) << "attach SYS pt on sys pd[sys]:" << MMU::directory(SYS) 
                     << ", with sys_pt[0] = " <<  hex << *((int *) si->pmm.sys_pt) << endl;
     db<Setup>(INF) << "sys_pd[sys+1];" << MMU::directory(SYS)+1 
-                    << ", with sys_pt[1] = " << hex << *((int *) (si->pmm.sys_pt+sizeof(Page_Table))) << endl;
+                    << ", with sys_pt[1] = " << hex << *((int *) (si->pmm.sys_pt+sizeof(Page_Table))) << endl;*/
     // Attach the OS (i.e. sys_pt)
     // One sys_pt for code
     sys_pd[MMU::directory(SYS)] = MMU::phy2pde(si->pmm.sys_pt);
@@ -695,9 +695,9 @@ void Setup::enable_paging()
     CPU::dsb();
     CPU::isb();
 
-    // Clear TTBCR for the system to use ttbr0 instead of 1
+    // Clear TTBCR for the system to use ttbx0 instead of 1
     CPU::ttbcr(0);
-    // Set ttbr0 with base address
+    // Set ttbx0 with base address
     CPU::ttbr0((Traits<System>::multitask) ? si->pmm.sys_pd : PAGE_TABLES);
 
     // Enable MMU through SCTLR and ACTLR
@@ -810,10 +810,10 @@ void Setup::load_parts()
 
 void Setup::adjust_perms()
 {
-    db<Setup>(TRC) << "Setup::adjust_perms(appc={b=" << (void *)si->pmm.app_code << ",s=" << MMU::pages(si->lm.app_code_size) << "}"
+    /*db<Setup>(TRC) << "Setup::adjust_perms(appc={b=" << (void *)si->pmm.app_code << ",s=" << MMU::pages(si->lm.app_code_size) << "}"
                    << ",appd={b=" << (void *)si->pmm.app_data << ",s=" << MMU::pages(si->lm.app_data_size) << "}"
                    << ",appe={b=" << (void *)si->pmm.app_extra << ",s=" << MMU::pages(si->lm.app_extra_size) << "}"
-                   << "})" << endl;
+                   << "})" << endl;*/
 
 
     // Get the logical address of the first APPLICATION Page Tables
@@ -843,7 +843,7 @@ void Setup::call_next()
         if(si->lm.has_ini) {
             if(cpu_id == 0) {
                 db<Setup>(TRC) << "Executing system's global constructors ..." << endl;
-                reinterpret_cast<void (*)()>((void *)si->lm.sys_entry)();
+                //reinterpret_cast<void (*)()>((void *)si->lm.sys_entry)();
             }
             ip = si->lm.ini_entry;
         } else if(si->lm.has_sys)
@@ -890,16 +890,16 @@ void _entry()
 {
     // Interrupt Vector Table
     // We use and indirection table for the ldr instructions because the offset can be to far from the PC to be encoded
-    ASM("               ldr pc, reset                                           \t\n\
-                        ldr pc, ui                                              \t\n\
-                        ldr pc, si                                              \t\n\
-                        ldr pc, pa                                              \t\n\
-                        ldr pc, da                                              \t\n\
+    ASM("               b reset                                           \t\n\
+                        b ui                                              \t\n\
+                        b si                                              \t\n\
+                        b pa                                              \t\n\
+                        b da                                              \t\n\
                         nop             // _reserved                            \t\n\
-                        ldr pc, irq                                             \t\n\
-                        ldr pc, fiq                                             \t\n\
+                        b irq                                             \t\n\
+                        b fiq                                             \t\n\
                                                                                 \t\n\
-                        .balign 32                                              \t\n\
+                        .balign 64                                              \t\n\
         reset:          .word _reset                                            \t\n\
         ui:             .word 0x0                                               \t\n\
         si:             .word 0x0                                               \t\n\
@@ -919,7 +919,7 @@ void _reset()
         CPU::cpsrc(cpsr);               // enter supervisor mode
         CPU::Reg address = CPU::ra();
         CPU::elr_hyp(address);
-        CPU::r12_to_psr();
+        CPU::x12_to_psr();
     }
 
     // Configure a stack for SVC mode, which will be used until the first Thread is created
@@ -928,13 +928,13 @@ void _reset()
 
     if(CPU::id() == 0) {
         // After a reset, we copy the vector table to 0x0000 to get a cleaner memory map (it is originally at 0x8000)
-        // An alternative would be to set vbar address via mrc p15, 0, r1, c12, c0, 0
-        CPU::r0(reinterpret_cast<CPU::Reg>(&_entry)); // load r0 with the source pointer
-        CPU::r1(Memory_Map::VECTOR_TABLE); // load r1 with the destination pointer
+        // An alternative would be to set vbar address via mrc p15, 0, x1, c12, c0, 0
+        CPU::x0(reinterpret_cast<CPU::Reg>(&_entry)); // load x0 with the source pointer
+        CPU::x1(Memory_Map::VECTOR_TABLE); // load x1 with the destination pointer
 
         // Copy the first 32 bytes
-        CPU::ldmia(); // load multiple registers from the memory pointed by r0 and auto-increment it accordingly
-        CPU::stmia(); // store multiple registers to the memory pointed by r1 and auto-increment it accordingly
+        CPU::ldmia(); // load multiple registers from the memory pointed by x0 and auto-increment it accordingly
+        CPU::stmia(); // store multiple registers to the memory pointed by x1 and auto-increment it accordingly
 
         // Repeat to copy the subsequent 32 bytes
         CPU::ldmia();
